Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> START LPAREN RPAREN bloque
Rule 2     declaracion -> vars
Rule 3     declaracion -> epsilon
Rule 4     vars -> VAR var
Rule 5     vars -> vars vars
Rule 6     var -> vardef COLON tipo SEMICOLON
Rule 7     var -> declaracionArr SEMICOLON
Rule 8     var -> declaracionMatrix SEMICOLON
Rule 9     vardef -> ID
Rule 10    tipo -> INT
Rule 11    tipo -> FLOAT
Rule 12    tipo -> BOOL
Rule 13    tipo -> STRING
Rule 14    bloque -> LCURLY declaracion estatutoExp RCURLY
Rule 15    bloqueReturn -> LCURLY declaracion estatutoExp returnexp RCURLY
Rule 16    estatutoExp -> estatuto SEMICOLON
Rule 17    estatutoExp -> estatutoExp estatutoExp
Rule 18    estatuto -> asignacion
Rule 19    estatuto -> condicion
Rule 20    estatuto -> whileLoop
Rule 21    estatuto -> doWhile
Rule 22    estatuto -> forLoop
Rule 23    estatuto -> escritura
Rule 24    estatuto -> funcion
Rule 25    estatuto -> functionCall
Rule 26    returnexp -> RETURN expresion SEMICOLON
Rule 27    asignacion -> ID EQUAL expresion
Rule 28    escritura -> PRINT LPAREN escrito RPAREN
Rule 29    escrito -> impr
Rule 30    escrito -> impr COMA impr
Rule 31    impr -> expresion
Rule 32    expresion -> exp
Rule 33    expresion -> condition
Rule 34    expresion -> functionCall
Rule 35    condition -> exp comparacion expresion
Rule 36    comparacion -> LESSTHAN
Rule 37    comparacion -> MORETHAN
Rule 38    comparacion -> ISEQUAL
Rule 39    comparacion -> NOTEQUAL
Rule 40    comparacion -> AND
Rule 41    comparacion -> OR
Rule 42    doWhile -> do bloque WHILE LPAREN expresion RPAREN
Rule 43    do -> DO
Rule 44    whileLoop -> WHILE startCondition expresion endCondition bloque
Rule 45    startCondition -> LPAREN
Rule 46    startCondition -> SEMICOLON
Rule 47    forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
Rule 48    condicion -> IF LPAREN expresion endCondition bloque condicionelse
Rule 49    endCondition -> RPAREN
Rule 50    endCondition -> SEMICOLON
Rule 51    condicionelse -> else bloque
Rule 52    condicionelse -> epsilon
Rule 53    else -> ELSE
Rule 54    funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
Rule 55    addArgs -> epsilon
Rule 56    funcdef -> ID
Rule 57    tiposreturn -> tiposFuncion bloqueReturn
Rule 58    tiposreturn -> VOID bloque
Rule 59    tiposFuncion -> INT
Rule 60    tiposFuncion -> FLOAT
Rule 61    tiposFuncion -> BOOL
Rule 62    tiposFuncion -> STRING
Rule 63    functionCall -> funCall paren funcArgs paren
Rule 64    funCall -> ID
Rule 65    funcArgs -> checkArgs
Rule 66    funcArgs -> funcArgs COMA funcArgs
Rule 67    funcArgs -> epsilon
Rule 68    checkArgs -> expresion
Rule 69    argumentos -> args
Rule 70    argumentos -> epsilon
Rule 71    args -> asignacion
Rule 72    args -> args COMA args
Rule 73    exp -> termino
Rule 74    exp -> termino signo exp
Rule 75    signo -> PLUS
Rule 76    signo -> MINUS
Rule 77    termino -> factor
Rule 78    termino -> factor operacion termino
Rule 79    operacion -> TIMES
Rule 80    operacion -> DIVIDE
Rule 81    operacion -> DIFF
Rule 82    operacion -> EXP
Rule 83    factor -> paren expresion paren
Rule 84    factor -> varcte
Rule 85    factor -> functionCall
Rule 86    paren -> LPAREN
Rule 87    paren -> RPAREN
Rule 88    epsilon -> <empty>
Rule 89    arrDef -> ID
Rule 90    declaracionArr -> arrDef LBRACKET INT RBRACKET COLON tipo
Rule 91    declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON tipo
Rule 92    arr -> callArr openBracket expresion abracket matrix
Rule 93    arr -> callArr openBracket expresion abracket epsilon
Rule 94    callArr -> ID
Rule 95    matrix -> openBracket expresion mbracket
Rule 96    openBracket -> LBRACKET
Rule 97    closeBracket -> RBRACKET
Rule 98    abracket -> closeBracket
Rule 99    mbracket -> closeBracket
Rule 100   varcte -> ID
Rule 101   varcte -> int
Rule 102   varcte -> float
Rule 103   varcte -> bool
Rule 104   varcte -> string
Rule 105   varcte -> matrix
Rule 106   varcte -> arr
Rule 107   int -> INT
Rule 108   float -> FLOAT
Rule 109   bool -> BOOL
Rule 110   string -> STRING

Terminals, with rules where they appear

AND                  : 40
BOOL                 : 12 61 109
COLON                : 6 54 90 91
COMA                 : 30 66 72
DIFF                 : 81
DIVIDE               : 80
DO                   : 43
ELSE                 : 53
EQUAL                : 27
EXP                  : 82
FLOAT                : 11 60 108
FOR                  : 47
FUNCTION             : 54
ID                   : 9 27 56 64 89 94 100
IF                   : 48
INT                  : 10 59 90 91 91 107
ISEQUAL              : 38
LBRACKET             : 90 91 91 96
LCURLY               : 14 15
LESSTHAN             : 36
LPAREN               : 1 28 42 45 47 48 54 86
MINUS                : 76
MORETHAN             : 37
NOTEQUAL             : 39
OR                   : 41
PLUS                 : 75
PRINT                : 28
RBRACKET             : 90 91 91 97
RCURLY               : 14 15
RETURN               : 26
RPAREN               : 1 28 42 47 49 54 87
SEMICOLON            : 6 7 8 16 26 46 50
START                : 1
STRING               : 13 62 110
TIMES                : 79
VAR                  : 4
VOID                 : 58
WHILE                : 42 44
error                : 

Nonterminals, with rules where they appear

abracket             : 92 93
addArgs              : 54
args                 : 69 72 72
argumentos           : 47
arr                  : 106
arrDef               : 90 91
asignacion           : 18 47 71
bloque               : 1 42 44 47 48 51 58
bloqueReturn         : 57
bool                 : 103
callArr              : 92 93
checkArgs            : 65
closeBracket         : 98 99
comparacion          : 35
condicion            : 19
condicionelse        : 48
condition            : 33
declaracion          : 14 15 54
declaracionArr       : 7
declaracionMatrix    : 8
do                   : 42
doWhile              : 21
else                 : 51
endCondition         : 44 47 48
epsilon              : 3 52 55 67 70 93
escrito              : 28
escritura            : 23
estatuto             : 16
estatutoExp          : 14 15 17 17
exp                  : 32 35 74
expresion            : 26 27 31 35 42 44 47 48 68 83 92 93 95
factor               : 77 78
float                : 102
forLoop              : 22
funCall              : 63
funcArgs             : 63 66 66
funcdef              : 54
funcion              : 24
functionCall         : 25 34 85
impr                 : 29 30 30
int                  : 101
matrix               : 92 105
mbracket             : 95
openBracket          : 92 93 95
operacion            : 78
paren                : 63 63 83 83
programa             : 0
returnexp            : 15
signo                : 74
startCondition       : 44 47
string               : 104
termino              : 73 74 78
tipo                 : 6 90 91
tiposFuncion         : 57
tiposreturn          : 54
var                  : 4
varcte               : 84
vardef               : 6
vars                 : 2 5 5
whileLoop            : 20

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . START LPAREN RPAREN bloque

    START           shift and go to state 2

    programa                       shift and go to state 1

state 1

    (0) S' -> programa .



state 2

    (1) programa -> START . LPAREN RPAREN bloque

    LPAREN          shift and go to state 3


state 3

    (1) programa -> START LPAREN . RPAREN bloque

    RPAREN          shift and go to state 4


state 4

    (1) programa -> START LPAREN RPAREN . bloque
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 5

state 5

    (1) programa -> START LPAREN RPAREN bloque .

    $end            reduce using rule 1 (programa -> START LPAREN RPAREN bloque .)


state 6

    (14) bloque -> LCURLY . declaracion estatutoExp RCURLY
    (2) declaracion -> . vars
    (3) declaracion -> . epsilon
    (4) vars -> . VAR var
    (5) vars -> . vars vars
    (88) epsilon -> .

    VAR             shift and go to state 10
    ID              reduce using rule 88 (epsilon -> .)
    IF              reduce using rule 88 (epsilon -> .)
    WHILE           reduce using rule 88 (epsilon -> .)
    FOR             reduce using rule 88 (epsilon -> .)
    PRINT           reduce using rule 88 (epsilon -> .)
    FUNCTION        reduce using rule 88 (epsilon -> .)
    DO              reduce using rule 88 (epsilon -> .)

    declaracion                    shift and go to state 7
    vars                           shift and go to state 8
    epsilon                        shift and go to state 9

state 7

    (14) bloque -> LCURLY declaracion . estatutoExp RCURLY
    (16) estatutoExp -> . estatuto SEMICOLON
    (17) estatutoExp -> . estatutoExp estatutoExp
    (18) estatuto -> . asignacion
    (19) estatuto -> . condicion
    (20) estatuto -> . whileLoop
    (21) estatuto -> . doWhile
    (22) estatuto -> . forLoop
    (23) estatuto -> . escritura
    (24) estatuto -> . funcion
    (25) estatuto -> . functionCall
    (27) asignacion -> . ID EQUAL expresion
    (48) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (44) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (42) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (47) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (28) escritura -> . PRINT LPAREN escrito RPAREN
    (54) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (63) functionCall -> . funCall paren funcArgs paren
    (43) do -> . DO
    (64) funCall -> . ID

    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    FUNCTION        shift and go to state 27
    DO              shift and go to state 29

    estatutoExp                    shift and go to state 11
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    condicion                      shift and go to state 14
    whileLoop                      shift and go to state 15
    doWhile                        shift and go to state 16
    forLoop                        shift and go to state 17
    escritura                      shift and go to state 18
    funcion                        shift and go to state 19
    functionCall                   shift and go to state 20
    do                             shift and go to state 24
    funCall                        shift and go to state 28

state 8

    (2) declaracion -> vars .
    (5) vars -> vars . vars
    (4) vars -> . VAR var
    (5) vars -> . vars vars

    ID              reduce using rule 2 (declaracion -> vars .)
    IF              reduce using rule 2 (declaracion -> vars .)
    WHILE           reduce using rule 2 (declaracion -> vars .)
    FOR             reduce using rule 2 (declaracion -> vars .)
    PRINT           reduce using rule 2 (declaracion -> vars .)
    FUNCTION        reduce using rule 2 (declaracion -> vars .)
    DO              reduce using rule 2 (declaracion -> vars .)
    RPAREN          reduce using rule 2 (declaracion -> vars .)
    VAR             shift and go to state 10

    vars                           shift and go to state 30

state 9

    (3) declaracion -> epsilon .

    ID              reduce using rule 3 (declaracion -> epsilon .)
    IF              reduce using rule 3 (declaracion -> epsilon .)
    WHILE           reduce using rule 3 (declaracion -> epsilon .)
    FOR             reduce using rule 3 (declaracion -> epsilon .)
    PRINT           reduce using rule 3 (declaracion -> epsilon .)
    FUNCTION        reduce using rule 3 (declaracion -> epsilon .)
    DO              reduce using rule 3 (declaracion -> epsilon .)
    RPAREN          reduce using rule 3 (declaracion -> epsilon .)


state 10

    (4) vars -> VAR . var
    (6) var -> . vardef COLON tipo SEMICOLON
    (7) var -> . declaracionArr SEMICOLON
    (8) var -> . declaracionMatrix SEMICOLON
    (9) vardef -> . ID
    (90) declaracionArr -> . arrDef LBRACKET INT RBRACKET COLON tipo
    (91) declaracionMatrix -> . arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON tipo
    (89) arrDef -> . ID

    ID              shift and go to state 35

    var                            shift and go to state 31
    vardef                         shift and go to state 32
    declaracionArr                 shift and go to state 33
    declaracionMatrix              shift and go to state 34
    arrDef                         shift and go to state 36

state 11

    (14) bloque -> LCURLY declaracion estatutoExp . RCURLY
    (17) estatutoExp -> estatutoExp . estatutoExp
    (16) estatutoExp -> . estatuto SEMICOLON
    (17) estatutoExp -> . estatutoExp estatutoExp
    (18) estatuto -> . asignacion
    (19) estatuto -> . condicion
    (20) estatuto -> . whileLoop
    (21) estatuto -> . doWhile
    (22) estatuto -> . forLoop
    (23) estatuto -> . escritura
    (24) estatuto -> . funcion
    (25) estatuto -> . functionCall
    (27) asignacion -> . ID EQUAL expresion
    (48) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (44) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (42) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (47) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (28) escritura -> . PRINT LPAREN escrito RPAREN
    (54) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (63) functionCall -> . funCall paren funcArgs paren
    (43) do -> . DO
    (64) funCall -> . ID

    RCURLY          shift and go to state 38
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    FUNCTION        shift and go to state 27
    DO              shift and go to state 29

    estatutoExp                    shift and go to state 37
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    condicion                      shift and go to state 14
    whileLoop                      shift and go to state 15
    doWhile                        shift and go to state 16
    forLoop                        shift and go to state 17
    escritura                      shift and go to state 18
    funcion                        shift and go to state 19
    functionCall                   shift and go to state 20
    do                             shift and go to state 24
    funCall                        shift and go to state 28

state 12

    (16) estatutoExp -> estatuto . SEMICOLON

    SEMICOLON       shift and go to state 39


state 13

    (18) estatuto -> asignacion .

    SEMICOLON       reduce using rule 18 (estatuto -> asignacion .)


state 14

    (19) estatuto -> condicion .

    SEMICOLON       reduce using rule 19 (estatuto -> condicion .)


state 15

    (20) estatuto -> whileLoop .

    SEMICOLON       reduce using rule 20 (estatuto -> whileLoop .)


state 16

    (21) estatuto -> doWhile .

    SEMICOLON       reduce using rule 21 (estatuto -> doWhile .)


state 17

    (22) estatuto -> forLoop .

    SEMICOLON       reduce using rule 22 (estatuto -> forLoop .)


state 18

    (23) estatuto -> escritura .

    SEMICOLON       reduce using rule 23 (estatuto -> escritura .)


state 19

    (24) estatuto -> funcion .

    SEMICOLON       reduce using rule 24 (estatuto -> funcion .)


state 20

    (25) estatuto -> functionCall .

    SEMICOLON       reduce using rule 25 (estatuto -> functionCall .)


state 21

    (27) asignacion -> ID . EQUAL expresion
    (64) funCall -> ID .

    EQUAL           shift and go to state 40
    LPAREN          reduce using rule 64 (funCall -> ID .)
    RPAREN          reduce using rule 64 (funCall -> ID .)


state 22

    (48) condicion -> IF . LPAREN expresion endCondition bloque condicionelse

    LPAREN          shift and go to state 41


state 23

    (44) whileLoop -> WHILE . startCondition expresion endCondition bloque
    (45) startCondition -> . LPAREN
    (46) startCondition -> . SEMICOLON

    LPAREN          shift and go to state 43
    SEMICOLON       shift and go to state 44

    startCondition                 shift and go to state 42

state 24

    (42) doWhile -> do . bloque WHILE LPAREN expresion RPAREN
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 45

state 25

    (47) forLoop -> FOR . LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque

    LPAREN          shift and go to state 46


state 26

    (28) escritura -> PRINT . LPAREN escrito RPAREN

    LPAREN          shift and go to state 47


state 27

    (54) funcion -> FUNCTION . funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (56) funcdef -> . ID

    ID              shift and go to state 49

    funcdef                        shift and go to state 48

state 28

    (63) functionCall -> funCall . paren funcArgs paren
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN

    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52

    paren                          shift and go to state 50

state 29

    (43) do -> DO .

    LCURLY          reduce using rule 43 (do -> DO .)


state 30

    (5) vars -> vars vars .
    (5) vars -> vars . vars
    (4) vars -> . VAR var
    (5) vars -> . vars vars

  ! shift/reduce conflict for VAR resolved as shift
    ID              reduce using rule 5 (vars -> vars vars .)
    IF              reduce using rule 5 (vars -> vars vars .)
    WHILE           reduce using rule 5 (vars -> vars vars .)
    FOR             reduce using rule 5 (vars -> vars vars .)
    PRINT           reduce using rule 5 (vars -> vars vars .)
    FUNCTION        reduce using rule 5 (vars -> vars vars .)
    DO              reduce using rule 5 (vars -> vars vars .)
    RPAREN          reduce using rule 5 (vars -> vars vars .)
    VAR             shift and go to state 10

  ! VAR             [ reduce using rule 5 (vars -> vars vars .) ]

    vars                           shift and go to state 30

state 31

    (4) vars -> VAR var .

    VAR             reduce using rule 4 (vars -> VAR var .)
    ID              reduce using rule 4 (vars -> VAR var .)
    IF              reduce using rule 4 (vars -> VAR var .)
    WHILE           reduce using rule 4 (vars -> VAR var .)
    FOR             reduce using rule 4 (vars -> VAR var .)
    PRINT           reduce using rule 4 (vars -> VAR var .)
    FUNCTION        reduce using rule 4 (vars -> VAR var .)
    DO              reduce using rule 4 (vars -> VAR var .)
    RPAREN          reduce using rule 4 (vars -> VAR var .)


state 32

    (6) var -> vardef . COLON tipo SEMICOLON

    COLON           shift and go to state 53


state 33

    (7) var -> declaracionArr . SEMICOLON

    SEMICOLON       shift and go to state 54


state 34

    (8) var -> declaracionMatrix . SEMICOLON

    SEMICOLON       shift and go to state 55


state 35

    (9) vardef -> ID .
    (89) arrDef -> ID .

    COLON           reduce using rule 9 (vardef -> ID .)
    LBRACKET        reduce using rule 89 (arrDef -> ID .)


state 36

    (90) declaracionArr -> arrDef . LBRACKET INT RBRACKET COLON tipo
    (91) declaracionMatrix -> arrDef . LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON tipo

    LBRACKET        shift and go to state 56


state 37

    (17) estatutoExp -> estatutoExp estatutoExp .
    (17) estatutoExp -> estatutoExp . estatutoExp
    (16) estatutoExp -> . estatuto SEMICOLON
    (17) estatutoExp -> . estatutoExp estatutoExp
    (18) estatuto -> . asignacion
    (19) estatuto -> . condicion
    (20) estatuto -> . whileLoop
    (21) estatuto -> . doWhile
    (22) estatuto -> . forLoop
    (23) estatuto -> . escritura
    (24) estatuto -> . funcion
    (25) estatuto -> . functionCall
    (27) asignacion -> . ID EQUAL expresion
    (48) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (44) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (42) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (47) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (28) escritura -> . PRINT LPAREN escrito RPAREN
    (54) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (63) functionCall -> . funCall paren funcArgs paren
    (43) do -> . DO
    (64) funCall -> . ID

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    RCURLY          reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .)
    RETURN          reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .)
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    FUNCTION        shift and go to state 27
    DO              shift and go to state 29

  ! ID              [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! IF              [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! WHILE           [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! FOR             [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! PRINT           [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! FUNCTION        [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! DO              [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]

    estatutoExp                    shift and go to state 37
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    condicion                      shift and go to state 14
    whileLoop                      shift and go to state 15
    doWhile                        shift and go to state 16
    forLoop                        shift and go to state 17
    escritura                      shift and go to state 18
    funcion                        shift and go to state 19
    functionCall                   shift and go to state 20
    do                             shift and go to state 24
    funCall                        shift and go to state 28

state 38

    (14) bloque -> LCURLY declaracion estatutoExp RCURLY .

    $end            reduce using rule 14 (bloque -> LCURLY declaracion estatutoExp RCURLY .)
    WHILE           reduce using rule 14 (bloque -> LCURLY declaracion estatutoExp RCURLY .)
    ELSE            reduce using rule 14 (bloque -> LCURLY declaracion estatutoExp RCURLY .)
    SEMICOLON       reduce using rule 14 (bloque -> LCURLY declaracion estatutoExp RCURLY .)


state 39

    (16) estatutoExp -> estatuto SEMICOLON .

    RCURLY          reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    ID              reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    IF              reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    WHILE           reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    FOR             reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    PRINT           reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    FUNCTION        reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    DO              reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    RETURN          reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)


state 40

    (27) asignacion -> ID EQUAL . expresion
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    expresion                      shift and go to state 58
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 41

    (48) condicion -> IF LPAREN . expresion endCondition bloque condicionelse
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    expresion                      shift and go to state 79
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 42

    (44) whileLoop -> WHILE startCondition . expresion endCondition bloque
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    expresion                      shift and go to state 80
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 43

    (45) startCondition -> LPAREN .

    ID              reduce using rule 45 (startCondition -> LPAREN .)
    LPAREN          reduce using rule 45 (startCondition -> LPAREN .)
    RPAREN          reduce using rule 45 (startCondition -> LPAREN .)
    INT             reduce using rule 45 (startCondition -> LPAREN .)
    FLOAT           reduce using rule 45 (startCondition -> LPAREN .)
    BOOL            reduce using rule 45 (startCondition -> LPAREN .)
    STRING          reduce using rule 45 (startCondition -> LPAREN .)
    LBRACKET        reduce using rule 45 (startCondition -> LPAREN .)


state 44

    (46) startCondition -> SEMICOLON .

    ID              reduce using rule 46 (startCondition -> SEMICOLON .)
    LPAREN          reduce using rule 46 (startCondition -> SEMICOLON .)
    RPAREN          reduce using rule 46 (startCondition -> SEMICOLON .)
    INT             reduce using rule 46 (startCondition -> SEMICOLON .)
    FLOAT           reduce using rule 46 (startCondition -> SEMICOLON .)
    BOOL            reduce using rule 46 (startCondition -> SEMICOLON .)
    STRING          reduce using rule 46 (startCondition -> SEMICOLON .)
    LBRACKET        reduce using rule 46 (startCondition -> SEMICOLON .)


state 45

    (42) doWhile -> do bloque . WHILE LPAREN expresion RPAREN

    WHILE           shift and go to state 81


state 46

    (47) forLoop -> FOR LPAREN . argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (69) argumentos -> . args
    (70) argumentos -> . epsilon
    (71) args -> . asignacion
    (72) args -> . args COMA args
    (88) epsilon -> .
    (27) asignacion -> . ID EQUAL expresion

    LPAREN          reduce using rule 88 (epsilon -> .)
    SEMICOLON       reduce using rule 88 (epsilon -> .)
    ID              shift and go to state 86

    argumentos                     shift and go to state 82
    asignacion                     shift and go to state 83
    args                           shift and go to state 84
    epsilon                        shift and go to state 85

state 47

    (28) escritura -> PRINT LPAREN . escrito RPAREN
    (29) escrito -> . impr
    (30) escrito -> . impr COMA impr
    (31) impr -> . expresion
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    escrito                        shift and go to state 87
    impr                           shift and go to state 88
    expresion                      shift and go to state 89
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 48

    (54) funcion -> FUNCTION funcdef . LPAREN declaracion addArgs RPAREN COLON tiposreturn

    LPAREN          shift and go to state 90


state 49

    (56) funcdef -> ID .

    LPAREN          reduce using rule 56 (funcdef -> ID .)


state 50

    (63) functionCall -> funCall paren . funcArgs paren
    (65) funcArgs -> . checkArgs
    (66) funcArgs -> . funcArgs COMA funcArgs
    (67) funcArgs -> . epsilon
    (68) checkArgs -> . expresion
    (88) epsilon -> .
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for RPAREN resolved as shift
    COMA            reduce using rule 88 (epsilon -> .)
    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

  ! LPAREN          [ reduce using rule 88 (epsilon -> .) ]
  ! RPAREN          [ reduce using rule 88 (epsilon -> .) ]

    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    funcArgs                       shift and go to state 91
    checkArgs                      shift and go to state 92
    epsilon                        shift and go to state 93
    expresion                      shift and go to state 94
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 51

    (86) paren -> LPAREN .

    ID              reduce using rule 86 (paren -> LPAREN .)
    LPAREN          reduce using rule 86 (paren -> LPAREN .)
    RPAREN          reduce using rule 86 (paren -> LPAREN .)
    INT             reduce using rule 86 (paren -> LPAREN .)
    FLOAT           reduce using rule 86 (paren -> LPAREN .)
    BOOL            reduce using rule 86 (paren -> LPAREN .)
    STRING          reduce using rule 86 (paren -> LPAREN .)
    LBRACKET        reduce using rule 86 (paren -> LPAREN .)
    COMA            reduce using rule 86 (paren -> LPAREN .)
    SEMICOLON       reduce using rule 86 (paren -> LPAREN .)
    TIMES           reduce using rule 86 (paren -> LPAREN .)
    DIVIDE          reduce using rule 86 (paren -> LPAREN .)
    DIFF            reduce using rule 86 (paren -> LPAREN .)
    EXP             reduce using rule 86 (paren -> LPAREN .)
    PLUS            reduce using rule 86 (paren -> LPAREN .)
    MINUS           reduce using rule 86 (paren -> LPAREN .)
    LESSTHAN        reduce using rule 86 (paren -> LPAREN .)
    MORETHAN        reduce using rule 86 (paren -> LPAREN .)
    ISEQUAL         reduce using rule 86 (paren -> LPAREN .)
    NOTEQUAL        reduce using rule 86 (paren -> LPAREN .)
    AND             reduce using rule 86 (paren -> LPAREN .)
    OR              reduce using rule 86 (paren -> LPAREN .)
    RBRACKET        reduce using rule 86 (paren -> LPAREN .)


state 52

    (87) paren -> RPAREN .

    ID              reduce using rule 87 (paren -> RPAREN .)
    LPAREN          reduce using rule 87 (paren -> RPAREN .)
    RPAREN          reduce using rule 87 (paren -> RPAREN .)
    INT             reduce using rule 87 (paren -> RPAREN .)
    FLOAT           reduce using rule 87 (paren -> RPAREN .)
    BOOL            reduce using rule 87 (paren -> RPAREN .)
    STRING          reduce using rule 87 (paren -> RPAREN .)
    LBRACKET        reduce using rule 87 (paren -> RPAREN .)
    COMA            reduce using rule 87 (paren -> RPAREN .)
    SEMICOLON       reduce using rule 87 (paren -> RPAREN .)
    TIMES           reduce using rule 87 (paren -> RPAREN .)
    DIVIDE          reduce using rule 87 (paren -> RPAREN .)
    DIFF            reduce using rule 87 (paren -> RPAREN .)
    EXP             reduce using rule 87 (paren -> RPAREN .)
    PLUS            reduce using rule 87 (paren -> RPAREN .)
    MINUS           reduce using rule 87 (paren -> RPAREN .)
    LESSTHAN        reduce using rule 87 (paren -> RPAREN .)
    MORETHAN        reduce using rule 87 (paren -> RPAREN .)
    ISEQUAL         reduce using rule 87 (paren -> RPAREN .)
    NOTEQUAL        reduce using rule 87 (paren -> RPAREN .)
    AND             reduce using rule 87 (paren -> RPAREN .)
    OR              reduce using rule 87 (paren -> RPAREN .)
    RBRACKET        reduce using rule 87 (paren -> RPAREN .)


state 53

    (6) var -> vardef COLON . tipo SEMICOLON
    (10) tipo -> . INT
    (11) tipo -> . FLOAT
    (12) tipo -> . BOOL
    (13) tipo -> . STRING

    INT             shift and go to state 96
    FLOAT           shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99

    tipo                           shift and go to state 95

state 54

    (7) var -> declaracionArr SEMICOLON .

    VAR             reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    ID              reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    IF              reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    WHILE           reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    FOR             reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    PRINT           reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    FUNCTION        reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    DO              reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    RPAREN          reduce using rule 7 (var -> declaracionArr SEMICOLON .)


state 55

    (8) var -> declaracionMatrix SEMICOLON .

    VAR             reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    ID              reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    IF              reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    WHILE           reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    FOR             reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    PRINT           reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    FUNCTION        reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    DO              reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    RPAREN          reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)


state 56

    (90) declaracionArr -> arrDef LBRACKET . INT RBRACKET COLON tipo
    (91) declaracionMatrix -> arrDef LBRACKET . INT RBRACKET LBRACKET INT RBRACKET COLON tipo

    INT             shift and go to state 100


state 57

    (64) funCall -> ID .
    (100) varcte -> ID .
    (94) callArr -> ID .

  ! reduce/reduce conflict for LPAREN resolved using rule 64 (funCall -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 64 (funCall -> ID .)
    LPAREN          reduce using rule 64 (funCall -> ID .)
    RPAREN          reduce using rule 64 (funCall -> ID .)
    TIMES           reduce using rule 100 (varcte -> ID .)
    DIVIDE          reduce using rule 100 (varcte -> ID .)
    DIFF            reduce using rule 100 (varcte -> ID .)
    EXP             reduce using rule 100 (varcte -> ID .)
    PLUS            reduce using rule 100 (varcte -> ID .)
    MINUS           reduce using rule 100 (varcte -> ID .)
    LESSTHAN        reduce using rule 100 (varcte -> ID .)
    MORETHAN        reduce using rule 100 (varcte -> ID .)
    ISEQUAL         reduce using rule 100 (varcte -> ID .)
    NOTEQUAL        reduce using rule 100 (varcte -> ID .)
    AND             reduce using rule 100 (varcte -> ID .)
    OR              reduce using rule 100 (varcte -> ID .)
    SEMICOLON       reduce using rule 100 (varcte -> ID .)
    COMA            reduce using rule 100 (varcte -> ID .)
    RBRACKET        reduce using rule 100 (varcte -> ID .)
    LBRACKET        reduce using rule 94 (callArr -> ID .)

  ! LPAREN          [ reduce using rule 100 (varcte -> ID .) ]
  ! RPAREN          [ reduce using rule 100 (varcte -> ID .) ]


state 58

    (27) asignacion -> ID EQUAL expresion .

    SEMICOLON       reduce using rule 27 (asignacion -> ID EQUAL expresion .)
    COMA            reduce using rule 27 (asignacion -> ID EQUAL expresion .)
    LPAREN          reduce using rule 27 (asignacion -> ID EQUAL expresion .)
    RPAREN          reduce using rule 27 (asignacion -> ID EQUAL expresion .)


state 59

    (32) expresion -> exp .
    (35) condition -> exp . comparacion expresion
    (36) comparacion -> . LESSTHAN
    (37) comparacion -> . MORETHAN
    (38) comparacion -> . ISEQUAL
    (39) comparacion -> . NOTEQUAL
    (40) comparacion -> . AND
    (41) comparacion -> . OR

    SEMICOLON       reduce using rule 32 (expresion -> exp .)
    COMA            reduce using rule 32 (expresion -> exp .)
    LPAREN          reduce using rule 32 (expresion -> exp .)
    RPAREN          reduce using rule 32 (expresion -> exp .)
    RBRACKET        reduce using rule 32 (expresion -> exp .)
    LESSTHAN        shift and go to state 102
    MORETHAN        shift and go to state 103
    ISEQUAL         shift and go to state 104
    NOTEQUAL        shift and go to state 105
    AND             shift and go to state 106
    OR              shift and go to state 107

    comparacion                    shift and go to state 101

state 60

    (33) expresion -> condition .

    SEMICOLON       reduce using rule 33 (expresion -> condition .)
    COMA            reduce using rule 33 (expresion -> condition .)
    LPAREN          reduce using rule 33 (expresion -> condition .)
    RPAREN          reduce using rule 33 (expresion -> condition .)
    RBRACKET        reduce using rule 33 (expresion -> condition .)


state 61

    (34) expresion -> functionCall .
    (85) factor -> functionCall .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 34 (expresion -> functionCall .)
  ! reduce/reduce conflict for COMA resolved using rule 34 (expresion -> functionCall .)
  ! reduce/reduce conflict for LPAREN resolved using rule 34 (expresion -> functionCall .)
  ! reduce/reduce conflict for RPAREN resolved using rule 34 (expresion -> functionCall .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 34 (expresion -> functionCall .)
    SEMICOLON       reduce using rule 34 (expresion -> functionCall .)
    COMA            reduce using rule 34 (expresion -> functionCall .)
    LPAREN          reduce using rule 34 (expresion -> functionCall .)
    RPAREN          reduce using rule 34 (expresion -> functionCall .)
    RBRACKET        reduce using rule 34 (expresion -> functionCall .)
    TIMES           reduce using rule 85 (factor -> functionCall .)
    DIVIDE          reduce using rule 85 (factor -> functionCall .)
    DIFF            reduce using rule 85 (factor -> functionCall .)
    EXP             reduce using rule 85 (factor -> functionCall .)
    PLUS            reduce using rule 85 (factor -> functionCall .)
    MINUS           reduce using rule 85 (factor -> functionCall .)
    LESSTHAN        reduce using rule 85 (factor -> functionCall .)
    MORETHAN        reduce using rule 85 (factor -> functionCall .)
    ISEQUAL         reduce using rule 85 (factor -> functionCall .)
    NOTEQUAL        reduce using rule 85 (factor -> functionCall .)
    AND             reduce using rule 85 (factor -> functionCall .)
    OR              reduce using rule 85 (factor -> functionCall .)

  ! SEMICOLON       [ reduce using rule 85 (factor -> functionCall .) ]
  ! COMA            [ reduce using rule 85 (factor -> functionCall .) ]
  ! LPAREN          [ reduce using rule 85 (factor -> functionCall .) ]
  ! RPAREN          [ reduce using rule 85 (factor -> functionCall .) ]
  ! RBRACKET        [ reduce using rule 85 (factor -> functionCall .) ]


state 62

    (73) exp -> termino .
    (74) exp -> termino . signo exp
    (75) signo -> . PLUS
    (76) signo -> . MINUS

    LESSTHAN        reduce using rule 73 (exp -> termino .)
    MORETHAN        reduce using rule 73 (exp -> termino .)
    ISEQUAL         reduce using rule 73 (exp -> termino .)
    NOTEQUAL        reduce using rule 73 (exp -> termino .)
    AND             reduce using rule 73 (exp -> termino .)
    OR              reduce using rule 73 (exp -> termino .)
    SEMICOLON       reduce using rule 73 (exp -> termino .)
    COMA            reduce using rule 73 (exp -> termino .)
    LPAREN          reduce using rule 73 (exp -> termino .)
    RPAREN          reduce using rule 73 (exp -> termino .)
    RBRACKET        reduce using rule 73 (exp -> termino .)
    PLUS            shift and go to state 109
    MINUS           shift and go to state 110

    signo                          shift and go to state 108

state 63

    (83) factor -> paren . expresion paren
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    paren                          shift and go to state 63
    expresion                      shift and go to state 111
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 64

    (77) termino -> factor .
    (78) termino -> factor . operacion termino
    (79) operacion -> . TIMES
    (80) operacion -> . DIVIDE
    (81) operacion -> . DIFF
    (82) operacion -> . EXP

    PLUS            reduce using rule 77 (termino -> factor .)
    MINUS           reduce using rule 77 (termino -> factor .)
    LESSTHAN        reduce using rule 77 (termino -> factor .)
    MORETHAN        reduce using rule 77 (termino -> factor .)
    ISEQUAL         reduce using rule 77 (termino -> factor .)
    NOTEQUAL        reduce using rule 77 (termino -> factor .)
    AND             reduce using rule 77 (termino -> factor .)
    OR              reduce using rule 77 (termino -> factor .)
    SEMICOLON       reduce using rule 77 (termino -> factor .)
    COMA            reduce using rule 77 (termino -> factor .)
    LPAREN          reduce using rule 77 (termino -> factor .)
    RPAREN          reduce using rule 77 (termino -> factor .)
    RBRACKET        reduce using rule 77 (termino -> factor .)
    TIMES           shift and go to state 113
    DIVIDE          shift and go to state 114
    DIFF            shift and go to state 115
    EXP             shift and go to state 116

    operacion                      shift and go to state 112

state 65

    (84) factor -> varcte .

    TIMES           reduce using rule 84 (factor -> varcte .)
    DIVIDE          reduce using rule 84 (factor -> varcte .)
    DIFF            reduce using rule 84 (factor -> varcte .)
    EXP             reduce using rule 84 (factor -> varcte .)
    PLUS            reduce using rule 84 (factor -> varcte .)
    MINUS           reduce using rule 84 (factor -> varcte .)
    LESSTHAN        reduce using rule 84 (factor -> varcte .)
    MORETHAN        reduce using rule 84 (factor -> varcte .)
    ISEQUAL         reduce using rule 84 (factor -> varcte .)
    NOTEQUAL        reduce using rule 84 (factor -> varcte .)
    AND             reduce using rule 84 (factor -> varcte .)
    OR              reduce using rule 84 (factor -> varcte .)
    SEMICOLON       reduce using rule 84 (factor -> varcte .)
    COMA            reduce using rule 84 (factor -> varcte .)
    LPAREN          reduce using rule 84 (factor -> varcte .)
    RPAREN          reduce using rule 84 (factor -> varcte .)
    RBRACKET        reduce using rule 84 (factor -> varcte .)


state 66

    (101) varcte -> int .

    TIMES           reduce using rule 101 (varcte -> int .)
    DIVIDE          reduce using rule 101 (varcte -> int .)
    DIFF            reduce using rule 101 (varcte -> int .)
    EXP             reduce using rule 101 (varcte -> int .)
    PLUS            reduce using rule 101 (varcte -> int .)
    MINUS           reduce using rule 101 (varcte -> int .)
    LESSTHAN        reduce using rule 101 (varcte -> int .)
    MORETHAN        reduce using rule 101 (varcte -> int .)
    ISEQUAL         reduce using rule 101 (varcte -> int .)
    NOTEQUAL        reduce using rule 101 (varcte -> int .)
    AND             reduce using rule 101 (varcte -> int .)
    OR              reduce using rule 101 (varcte -> int .)
    SEMICOLON       reduce using rule 101 (varcte -> int .)
    COMA            reduce using rule 101 (varcte -> int .)
    LPAREN          reduce using rule 101 (varcte -> int .)
    RPAREN          reduce using rule 101 (varcte -> int .)
    RBRACKET        reduce using rule 101 (varcte -> int .)


state 67

    (102) varcte -> float .

    TIMES           reduce using rule 102 (varcte -> float .)
    DIVIDE          reduce using rule 102 (varcte -> float .)
    DIFF            reduce using rule 102 (varcte -> float .)
    EXP             reduce using rule 102 (varcte -> float .)
    PLUS            reduce using rule 102 (varcte -> float .)
    MINUS           reduce using rule 102 (varcte -> float .)
    LESSTHAN        reduce using rule 102 (varcte -> float .)
    MORETHAN        reduce using rule 102 (varcte -> float .)
    ISEQUAL         reduce using rule 102 (varcte -> float .)
    NOTEQUAL        reduce using rule 102 (varcte -> float .)
    AND             reduce using rule 102 (varcte -> float .)
    OR              reduce using rule 102 (varcte -> float .)
    SEMICOLON       reduce using rule 102 (varcte -> float .)
    COMA            reduce using rule 102 (varcte -> float .)
    LPAREN          reduce using rule 102 (varcte -> float .)
    RPAREN          reduce using rule 102 (varcte -> float .)
    RBRACKET        reduce using rule 102 (varcte -> float .)


state 68

    (103) varcte -> bool .

    TIMES           reduce using rule 103 (varcte -> bool .)
    DIVIDE          reduce using rule 103 (varcte -> bool .)
    DIFF            reduce using rule 103 (varcte -> bool .)
    EXP             reduce using rule 103 (varcte -> bool .)
    PLUS            reduce using rule 103 (varcte -> bool .)
    MINUS           reduce using rule 103 (varcte -> bool .)
    LESSTHAN        reduce using rule 103 (varcte -> bool .)
    MORETHAN        reduce using rule 103 (varcte -> bool .)
    ISEQUAL         reduce using rule 103 (varcte -> bool .)
    NOTEQUAL        reduce using rule 103 (varcte -> bool .)
    AND             reduce using rule 103 (varcte -> bool .)
    OR              reduce using rule 103 (varcte -> bool .)
    SEMICOLON       reduce using rule 103 (varcte -> bool .)
    COMA            reduce using rule 103 (varcte -> bool .)
    LPAREN          reduce using rule 103 (varcte -> bool .)
    RPAREN          reduce using rule 103 (varcte -> bool .)
    RBRACKET        reduce using rule 103 (varcte -> bool .)


state 69

    (104) varcte -> string .

    TIMES           reduce using rule 104 (varcte -> string .)
    DIVIDE          reduce using rule 104 (varcte -> string .)
    DIFF            reduce using rule 104 (varcte -> string .)
    EXP             reduce using rule 104 (varcte -> string .)
    PLUS            reduce using rule 104 (varcte -> string .)
    MINUS           reduce using rule 104 (varcte -> string .)
    LESSTHAN        reduce using rule 104 (varcte -> string .)
    MORETHAN        reduce using rule 104 (varcte -> string .)
    ISEQUAL         reduce using rule 104 (varcte -> string .)
    NOTEQUAL        reduce using rule 104 (varcte -> string .)
    AND             reduce using rule 104 (varcte -> string .)
    OR              reduce using rule 104 (varcte -> string .)
    SEMICOLON       reduce using rule 104 (varcte -> string .)
    COMA            reduce using rule 104 (varcte -> string .)
    LPAREN          reduce using rule 104 (varcte -> string .)
    RPAREN          reduce using rule 104 (varcte -> string .)
    RBRACKET        reduce using rule 104 (varcte -> string .)


state 70

    (105) varcte -> matrix .

    TIMES           reduce using rule 105 (varcte -> matrix .)
    DIVIDE          reduce using rule 105 (varcte -> matrix .)
    DIFF            reduce using rule 105 (varcte -> matrix .)
    EXP             reduce using rule 105 (varcte -> matrix .)
    PLUS            reduce using rule 105 (varcte -> matrix .)
    MINUS           reduce using rule 105 (varcte -> matrix .)
    LESSTHAN        reduce using rule 105 (varcte -> matrix .)
    MORETHAN        reduce using rule 105 (varcte -> matrix .)
    ISEQUAL         reduce using rule 105 (varcte -> matrix .)
    NOTEQUAL        reduce using rule 105 (varcte -> matrix .)
    AND             reduce using rule 105 (varcte -> matrix .)
    OR              reduce using rule 105 (varcte -> matrix .)
    SEMICOLON       reduce using rule 105 (varcte -> matrix .)
    COMA            reduce using rule 105 (varcte -> matrix .)
    LPAREN          reduce using rule 105 (varcte -> matrix .)
    RPAREN          reduce using rule 105 (varcte -> matrix .)
    RBRACKET        reduce using rule 105 (varcte -> matrix .)


state 71

    (106) varcte -> arr .

    TIMES           reduce using rule 106 (varcte -> arr .)
    DIVIDE          reduce using rule 106 (varcte -> arr .)
    DIFF            reduce using rule 106 (varcte -> arr .)
    EXP             reduce using rule 106 (varcte -> arr .)
    PLUS            reduce using rule 106 (varcte -> arr .)
    MINUS           reduce using rule 106 (varcte -> arr .)
    LESSTHAN        reduce using rule 106 (varcte -> arr .)
    MORETHAN        reduce using rule 106 (varcte -> arr .)
    ISEQUAL         reduce using rule 106 (varcte -> arr .)
    NOTEQUAL        reduce using rule 106 (varcte -> arr .)
    AND             reduce using rule 106 (varcte -> arr .)
    OR              reduce using rule 106 (varcte -> arr .)
    SEMICOLON       reduce using rule 106 (varcte -> arr .)
    COMA            reduce using rule 106 (varcte -> arr .)
    LPAREN          reduce using rule 106 (varcte -> arr .)
    RPAREN          reduce using rule 106 (varcte -> arr .)
    RBRACKET        reduce using rule 106 (varcte -> arr .)


state 72

    (107) int -> INT .

    TIMES           reduce using rule 107 (int -> INT .)
    DIVIDE          reduce using rule 107 (int -> INT .)
    DIFF            reduce using rule 107 (int -> INT .)
    EXP             reduce using rule 107 (int -> INT .)
    PLUS            reduce using rule 107 (int -> INT .)
    MINUS           reduce using rule 107 (int -> INT .)
    LESSTHAN        reduce using rule 107 (int -> INT .)
    MORETHAN        reduce using rule 107 (int -> INT .)
    ISEQUAL         reduce using rule 107 (int -> INT .)
    NOTEQUAL        reduce using rule 107 (int -> INT .)
    AND             reduce using rule 107 (int -> INT .)
    OR              reduce using rule 107 (int -> INT .)
    SEMICOLON       reduce using rule 107 (int -> INT .)
    COMA            reduce using rule 107 (int -> INT .)
    LPAREN          reduce using rule 107 (int -> INT .)
    RPAREN          reduce using rule 107 (int -> INT .)
    RBRACKET        reduce using rule 107 (int -> INT .)


state 73

    (108) float -> FLOAT .

    TIMES           reduce using rule 108 (float -> FLOAT .)
    DIVIDE          reduce using rule 108 (float -> FLOAT .)
    DIFF            reduce using rule 108 (float -> FLOAT .)
    EXP             reduce using rule 108 (float -> FLOAT .)
    PLUS            reduce using rule 108 (float -> FLOAT .)
    MINUS           reduce using rule 108 (float -> FLOAT .)
    LESSTHAN        reduce using rule 108 (float -> FLOAT .)
    MORETHAN        reduce using rule 108 (float -> FLOAT .)
    ISEQUAL         reduce using rule 108 (float -> FLOAT .)
    NOTEQUAL        reduce using rule 108 (float -> FLOAT .)
    AND             reduce using rule 108 (float -> FLOAT .)
    OR              reduce using rule 108 (float -> FLOAT .)
    SEMICOLON       reduce using rule 108 (float -> FLOAT .)
    COMA            reduce using rule 108 (float -> FLOAT .)
    LPAREN          reduce using rule 108 (float -> FLOAT .)
    RPAREN          reduce using rule 108 (float -> FLOAT .)
    RBRACKET        reduce using rule 108 (float -> FLOAT .)


state 74

    (109) bool -> BOOL .

    TIMES           reduce using rule 109 (bool -> BOOL .)
    DIVIDE          reduce using rule 109 (bool -> BOOL .)
    DIFF            reduce using rule 109 (bool -> BOOL .)
    EXP             reduce using rule 109 (bool -> BOOL .)
    PLUS            reduce using rule 109 (bool -> BOOL .)
    MINUS           reduce using rule 109 (bool -> BOOL .)
    LESSTHAN        reduce using rule 109 (bool -> BOOL .)
    MORETHAN        reduce using rule 109 (bool -> BOOL .)
    ISEQUAL         reduce using rule 109 (bool -> BOOL .)
    NOTEQUAL        reduce using rule 109 (bool -> BOOL .)
    AND             reduce using rule 109 (bool -> BOOL .)
    OR              reduce using rule 109 (bool -> BOOL .)
    SEMICOLON       reduce using rule 109 (bool -> BOOL .)
    COMA            reduce using rule 109 (bool -> BOOL .)
    LPAREN          reduce using rule 109 (bool -> BOOL .)
    RPAREN          reduce using rule 109 (bool -> BOOL .)
    RBRACKET        reduce using rule 109 (bool -> BOOL .)


state 75

    (110) string -> STRING .

    TIMES           reduce using rule 110 (string -> STRING .)
    DIVIDE          reduce using rule 110 (string -> STRING .)
    DIFF            reduce using rule 110 (string -> STRING .)
    EXP             reduce using rule 110 (string -> STRING .)
    PLUS            reduce using rule 110 (string -> STRING .)
    MINUS           reduce using rule 110 (string -> STRING .)
    LESSTHAN        reduce using rule 110 (string -> STRING .)
    MORETHAN        reduce using rule 110 (string -> STRING .)
    ISEQUAL         reduce using rule 110 (string -> STRING .)
    NOTEQUAL        reduce using rule 110 (string -> STRING .)
    AND             reduce using rule 110 (string -> STRING .)
    OR              reduce using rule 110 (string -> STRING .)
    SEMICOLON       reduce using rule 110 (string -> STRING .)
    COMA            reduce using rule 110 (string -> STRING .)
    LPAREN          reduce using rule 110 (string -> STRING .)
    RPAREN          reduce using rule 110 (string -> STRING .)
    RBRACKET        reduce using rule 110 (string -> STRING .)


state 76

    (95) matrix -> openBracket . expresion mbracket
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    openBracket                    shift and go to state 76
    expresion                      shift and go to state 117
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    callArr                        shift and go to state 77

state 77

    (92) arr -> callArr . openBracket expresion abracket matrix
    (93) arr -> callArr . openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET

    LBRACKET        shift and go to state 78

    openBracket                    shift and go to state 118

state 78

    (96) openBracket -> LBRACKET .

    ID              reduce using rule 96 (openBracket -> LBRACKET .)
    LPAREN          reduce using rule 96 (openBracket -> LBRACKET .)
    RPAREN          reduce using rule 96 (openBracket -> LBRACKET .)
    INT             reduce using rule 96 (openBracket -> LBRACKET .)
    FLOAT           reduce using rule 96 (openBracket -> LBRACKET .)
    BOOL            reduce using rule 96 (openBracket -> LBRACKET .)
    STRING          reduce using rule 96 (openBracket -> LBRACKET .)
    LBRACKET        reduce using rule 96 (openBracket -> LBRACKET .)


state 79

    (48) condicion -> IF LPAREN expresion . endCondition bloque condicionelse
    (49) endCondition -> . RPAREN
    (50) endCondition -> . SEMICOLON

    RPAREN          shift and go to state 120
    SEMICOLON       shift and go to state 121

    endCondition                   shift and go to state 119

state 80

    (44) whileLoop -> WHILE startCondition expresion . endCondition bloque
    (49) endCondition -> . RPAREN
    (50) endCondition -> . SEMICOLON

    RPAREN          shift and go to state 120
    SEMICOLON       shift and go to state 121

    endCondition                   shift and go to state 122

state 81

    (42) doWhile -> do bloque WHILE . LPAREN expresion RPAREN

    LPAREN          shift and go to state 123


state 82

    (47) forLoop -> FOR LPAREN argumentos . startCondition expresion endCondition asignacion RPAREN bloque
    (45) startCondition -> . LPAREN
    (46) startCondition -> . SEMICOLON

    LPAREN          shift and go to state 43
    SEMICOLON       shift and go to state 44

    startCondition                 shift and go to state 124

state 83

    (71) args -> asignacion .

    COMA            reduce using rule 71 (args -> asignacion .)
    LPAREN          reduce using rule 71 (args -> asignacion .)
    SEMICOLON       reduce using rule 71 (args -> asignacion .)


state 84

    (69) argumentos -> args .
    (72) args -> args . COMA args

    LPAREN          reduce using rule 69 (argumentos -> args .)
    SEMICOLON       reduce using rule 69 (argumentos -> args .)
    COMA            shift and go to state 125


state 85

    (70) argumentos -> epsilon .

    LPAREN          reduce using rule 70 (argumentos -> epsilon .)
    SEMICOLON       reduce using rule 70 (argumentos -> epsilon .)


state 86

    (27) asignacion -> ID . EQUAL expresion

    EQUAL           shift and go to state 40


state 87

    (28) escritura -> PRINT LPAREN escrito . RPAREN

    RPAREN          shift and go to state 126


state 88

    (29) escrito -> impr .
    (30) escrito -> impr . COMA impr

    RPAREN          reduce using rule 29 (escrito -> impr .)
    COMA            shift and go to state 127


state 89

    (31) impr -> expresion .

    COMA            reduce using rule 31 (impr -> expresion .)
    RPAREN          reduce using rule 31 (impr -> expresion .)


state 90

    (54) funcion -> FUNCTION funcdef LPAREN . declaracion addArgs RPAREN COLON tiposreturn
    (2) declaracion -> . vars
    (3) declaracion -> . epsilon
    (4) vars -> . VAR var
    (5) vars -> . vars vars
    (88) epsilon -> .

    VAR             shift and go to state 10
    RPAREN          reduce using rule 88 (epsilon -> .)

    declaracion                    shift and go to state 128
    vars                           shift and go to state 8
    epsilon                        shift and go to state 9

state 91

    (63) functionCall -> funCall paren funcArgs . paren
    (66) funcArgs -> funcArgs . COMA funcArgs
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN

    COMA            shift and go to state 130
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52

    paren                          shift and go to state 129

state 92

    (65) funcArgs -> checkArgs .

    COMA            reduce using rule 65 (funcArgs -> checkArgs .)
    LPAREN          reduce using rule 65 (funcArgs -> checkArgs .)
    RPAREN          reduce using rule 65 (funcArgs -> checkArgs .)


state 93

    (67) funcArgs -> epsilon .

    COMA            reduce using rule 67 (funcArgs -> epsilon .)
    LPAREN          reduce using rule 67 (funcArgs -> epsilon .)
    RPAREN          reduce using rule 67 (funcArgs -> epsilon .)


state 94

    (68) checkArgs -> expresion .

    COMA            reduce using rule 68 (checkArgs -> expresion .)
    LPAREN          reduce using rule 68 (checkArgs -> expresion .)
    RPAREN          reduce using rule 68 (checkArgs -> expresion .)


state 95

    (6) var -> vardef COLON tipo . SEMICOLON

    SEMICOLON       shift and go to state 131


state 96

    (10) tipo -> INT .

    SEMICOLON       reduce using rule 10 (tipo -> INT .)


state 97

    (11) tipo -> FLOAT .

    SEMICOLON       reduce using rule 11 (tipo -> FLOAT .)


state 98

    (12) tipo -> BOOL .

    SEMICOLON       reduce using rule 12 (tipo -> BOOL .)


state 99

    (13) tipo -> STRING .

    SEMICOLON       reduce using rule 13 (tipo -> STRING .)


state 100

    (90) declaracionArr -> arrDef LBRACKET INT . RBRACKET COLON tipo
    (91) declaracionMatrix -> arrDef LBRACKET INT . RBRACKET LBRACKET INT RBRACKET COLON tipo

    RBRACKET        shift and go to state 132


state 101

    (35) condition -> exp comparacion . expresion
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    exp                            shift and go to state 59
    expresion                      shift and go to state 133
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 102

    (36) comparacion -> LESSTHAN .

    ID              reduce using rule 36 (comparacion -> LESSTHAN .)
    LPAREN          reduce using rule 36 (comparacion -> LESSTHAN .)
    RPAREN          reduce using rule 36 (comparacion -> LESSTHAN .)
    INT             reduce using rule 36 (comparacion -> LESSTHAN .)
    FLOAT           reduce using rule 36 (comparacion -> LESSTHAN .)
    BOOL            reduce using rule 36 (comparacion -> LESSTHAN .)
    STRING          reduce using rule 36 (comparacion -> LESSTHAN .)
    LBRACKET        reduce using rule 36 (comparacion -> LESSTHAN .)


state 103

    (37) comparacion -> MORETHAN .

    ID              reduce using rule 37 (comparacion -> MORETHAN .)
    LPAREN          reduce using rule 37 (comparacion -> MORETHAN .)
    RPAREN          reduce using rule 37 (comparacion -> MORETHAN .)
    INT             reduce using rule 37 (comparacion -> MORETHAN .)
    FLOAT           reduce using rule 37 (comparacion -> MORETHAN .)
    BOOL            reduce using rule 37 (comparacion -> MORETHAN .)
    STRING          reduce using rule 37 (comparacion -> MORETHAN .)
    LBRACKET        reduce using rule 37 (comparacion -> MORETHAN .)


state 104

    (38) comparacion -> ISEQUAL .

    ID              reduce using rule 38 (comparacion -> ISEQUAL .)
    LPAREN          reduce using rule 38 (comparacion -> ISEQUAL .)
    RPAREN          reduce using rule 38 (comparacion -> ISEQUAL .)
    INT             reduce using rule 38 (comparacion -> ISEQUAL .)
    FLOAT           reduce using rule 38 (comparacion -> ISEQUAL .)
    BOOL            reduce using rule 38 (comparacion -> ISEQUAL .)
    STRING          reduce using rule 38 (comparacion -> ISEQUAL .)
    LBRACKET        reduce using rule 38 (comparacion -> ISEQUAL .)


state 105

    (39) comparacion -> NOTEQUAL .

    ID              reduce using rule 39 (comparacion -> NOTEQUAL .)
    LPAREN          reduce using rule 39 (comparacion -> NOTEQUAL .)
    RPAREN          reduce using rule 39 (comparacion -> NOTEQUAL .)
    INT             reduce using rule 39 (comparacion -> NOTEQUAL .)
    FLOAT           reduce using rule 39 (comparacion -> NOTEQUAL .)
    BOOL            reduce using rule 39 (comparacion -> NOTEQUAL .)
    STRING          reduce using rule 39 (comparacion -> NOTEQUAL .)
    LBRACKET        reduce using rule 39 (comparacion -> NOTEQUAL .)


state 106

    (40) comparacion -> AND .

    ID              reduce using rule 40 (comparacion -> AND .)
    LPAREN          reduce using rule 40 (comparacion -> AND .)
    RPAREN          reduce using rule 40 (comparacion -> AND .)
    INT             reduce using rule 40 (comparacion -> AND .)
    FLOAT           reduce using rule 40 (comparacion -> AND .)
    BOOL            reduce using rule 40 (comparacion -> AND .)
    STRING          reduce using rule 40 (comparacion -> AND .)
    LBRACKET        reduce using rule 40 (comparacion -> AND .)


state 107

    (41) comparacion -> OR .

    ID              reduce using rule 41 (comparacion -> OR .)
    LPAREN          reduce using rule 41 (comparacion -> OR .)
    RPAREN          reduce using rule 41 (comparacion -> OR .)
    INT             reduce using rule 41 (comparacion -> OR .)
    FLOAT           reduce using rule 41 (comparacion -> OR .)
    BOOL            reduce using rule 41 (comparacion -> OR .)
    STRING          reduce using rule 41 (comparacion -> OR .)
    LBRACKET        reduce using rule 41 (comparacion -> OR .)


state 108

    (74) exp -> termino signo . exp
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (63) functionCall -> . funCall paren funcArgs paren
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (64) funCall -> . ID
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    ID              shift and go to state 136
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    termino                        shift and go to state 62
    exp                            shift and go to state 134
    factor                         shift and go to state 64
    paren                          shift and go to state 63
    varcte                         shift and go to state 65
    functionCall                   shift and go to state 135
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    funCall                        shift and go to state 28
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 109

    (75) signo -> PLUS .

    LPAREN          reduce using rule 75 (signo -> PLUS .)
    RPAREN          reduce using rule 75 (signo -> PLUS .)
    ID              reduce using rule 75 (signo -> PLUS .)
    INT             reduce using rule 75 (signo -> PLUS .)
    FLOAT           reduce using rule 75 (signo -> PLUS .)
    BOOL            reduce using rule 75 (signo -> PLUS .)
    STRING          reduce using rule 75 (signo -> PLUS .)
    LBRACKET        reduce using rule 75 (signo -> PLUS .)


state 110

    (76) signo -> MINUS .

    LPAREN          reduce using rule 76 (signo -> MINUS .)
    RPAREN          reduce using rule 76 (signo -> MINUS .)
    ID              reduce using rule 76 (signo -> MINUS .)
    INT             reduce using rule 76 (signo -> MINUS .)
    FLOAT           reduce using rule 76 (signo -> MINUS .)
    BOOL            reduce using rule 76 (signo -> MINUS .)
    STRING          reduce using rule 76 (signo -> MINUS .)
    LBRACKET        reduce using rule 76 (signo -> MINUS .)


state 111

    (83) factor -> paren expresion . paren
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN

    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52

    paren                          shift and go to state 137

state 112

    (78) termino -> factor operacion . termino
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (63) functionCall -> . funCall paren funcArgs paren
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (64) funCall -> . ID
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    ID              shift and go to state 136
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    factor                         shift and go to state 64
    termino                        shift and go to state 138
    paren                          shift and go to state 63
    varcte                         shift and go to state 65
    functionCall                   shift and go to state 135
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    funCall                        shift and go to state 28
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 113

    (79) operacion -> TIMES .

    LPAREN          reduce using rule 79 (operacion -> TIMES .)
    RPAREN          reduce using rule 79 (operacion -> TIMES .)
    ID              reduce using rule 79 (operacion -> TIMES .)
    INT             reduce using rule 79 (operacion -> TIMES .)
    FLOAT           reduce using rule 79 (operacion -> TIMES .)
    BOOL            reduce using rule 79 (operacion -> TIMES .)
    STRING          reduce using rule 79 (operacion -> TIMES .)
    LBRACKET        reduce using rule 79 (operacion -> TIMES .)


state 114

    (80) operacion -> DIVIDE .

    LPAREN          reduce using rule 80 (operacion -> DIVIDE .)
    RPAREN          reduce using rule 80 (operacion -> DIVIDE .)
    ID              reduce using rule 80 (operacion -> DIVIDE .)
    INT             reduce using rule 80 (operacion -> DIVIDE .)
    FLOAT           reduce using rule 80 (operacion -> DIVIDE .)
    BOOL            reduce using rule 80 (operacion -> DIVIDE .)
    STRING          reduce using rule 80 (operacion -> DIVIDE .)
    LBRACKET        reduce using rule 80 (operacion -> DIVIDE .)


state 115

    (81) operacion -> DIFF .

    LPAREN          reduce using rule 81 (operacion -> DIFF .)
    RPAREN          reduce using rule 81 (operacion -> DIFF .)
    ID              reduce using rule 81 (operacion -> DIFF .)
    INT             reduce using rule 81 (operacion -> DIFF .)
    FLOAT           reduce using rule 81 (operacion -> DIFF .)
    BOOL            reduce using rule 81 (operacion -> DIFF .)
    STRING          reduce using rule 81 (operacion -> DIFF .)
    LBRACKET        reduce using rule 81 (operacion -> DIFF .)


state 116

    (82) operacion -> EXP .

    LPAREN          reduce using rule 82 (operacion -> EXP .)
    RPAREN          reduce using rule 82 (operacion -> EXP .)
    ID              reduce using rule 82 (operacion -> EXP .)
    INT             reduce using rule 82 (operacion -> EXP .)
    FLOAT           reduce using rule 82 (operacion -> EXP .)
    BOOL            reduce using rule 82 (operacion -> EXP .)
    STRING          reduce using rule 82 (operacion -> EXP .)
    LBRACKET        reduce using rule 82 (operacion -> EXP .)


state 117

    (95) matrix -> openBracket expresion . mbracket
    (99) mbracket -> . closeBracket
    (97) closeBracket -> . RBRACKET

    RBRACKET        shift and go to state 141

    mbracket                       shift and go to state 139
    closeBracket                   shift and go to state 140

state 118

    (92) arr -> callArr openBracket . expresion abracket matrix
    (93) arr -> callArr openBracket . expresion abracket epsilon
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    callArr                        shift and go to state 77
    openBracket                    shift and go to state 76
    expresion                      shift and go to state 142
    matrix                         shift and go to state 70
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    arr                            shift and go to state 71

state 119

    (48) condicion -> IF LPAREN expresion endCondition . bloque condicionelse
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 143

state 120

    (49) endCondition -> RPAREN .

    LCURLY          reduce using rule 49 (endCondition -> RPAREN .)
    ID              reduce using rule 49 (endCondition -> RPAREN .)


state 121

    (50) endCondition -> SEMICOLON .

    LCURLY          reduce using rule 50 (endCondition -> SEMICOLON .)
    ID              reduce using rule 50 (endCondition -> SEMICOLON .)


state 122

    (44) whileLoop -> WHILE startCondition expresion endCondition . bloque
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 144

state 123

    (42) doWhile -> do bloque WHILE LPAREN . expresion RPAREN
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    expresion                      shift and go to state 145
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 124

    (47) forLoop -> FOR LPAREN argumentos startCondition . expresion endCondition asignacion RPAREN bloque
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    expresion                      shift and go to state 146
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 125

    (72) args -> args COMA . args
    (71) args -> . asignacion
    (72) args -> . args COMA args
    (27) asignacion -> . ID EQUAL expresion

    ID              shift and go to state 86

    args                           shift and go to state 147
    asignacion                     shift and go to state 83

state 126

    (28) escritura -> PRINT LPAREN escrito RPAREN .

    SEMICOLON       reduce using rule 28 (escritura -> PRINT LPAREN escrito RPAREN .)


state 127

    (30) escrito -> impr COMA . impr
    (31) impr -> . expresion
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    impr                           shift and go to state 148
    expresion                      shift and go to state 89
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 128

    (54) funcion -> FUNCTION funcdef LPAREN declaracion . addArgs RPAREN COLON tiposreturn
    (55) addArgs -> . epsilon
    (88) epsilon -> .

    RPAREN          reduce using rule 88 (epsilon -> .)

    addArgs                        shift and go to state 149
    epsilon                        shift and go to state 150

state 129

    (63) functionCall -> funCall paren funcArgs paren .

    SEMICOLON       reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    COMA            reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    LPAREN          reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    RPAREN          reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    TIMES           reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    DIVIDE          reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    DIFF            reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    EXP             reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    PLUS            reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    MINUS           reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    LESSTHAN        reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    MORETHAN        reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    ISEQUAL         reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    NOTEQUAL        reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    AND             reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    OR              reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)
    RBRACKET        reduce using rule 63 (functionCall -> funCall paren funcArgs paren .)


state 130

    (66) funcArgs -> funcArgs COMA . funcArgs
    (65) funcArgs -> . checkArgs
    (66) funcArgs -> . funcArgs COMA funcArgs
    (67) funcArgs -> . epsilon
    (68) checkArgs -> . expresion
    (88) epsilon -> .
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for RPAREN resolved as shift
    COMA            reduce using rule 88 (epsilon -> .)
    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

  ! LPAREN          [ reduce using rule 88 (epsilon -> .) ]
  ! RPAREN          [ reduce using rule 88 (epsilon -> .) ]

    funcArgs                       shift and go to state 151
    checkArgs                      shift and go to state 92
    epsilon                        shift and go to state 93
    expresion                      shift and go to state 94
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 131

    (6) var -> vardef COLON tipo SEMICOLON .

    VAR             reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    ID              reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    IF              reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    WHILE           reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    FOR             reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    PRINT           reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    FUNCTION        reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    DO              reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    RPAREN          reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)


state 132

    (90) declaracionArr -> arrDef LBRACKET INT RBRACKET . COLON tipo
    (91) declaracionMatrix -> arrDef LBRACKET INT RBRACKET . LBRACKET INT RBRACKET COLON tipo

    COLON           shift and go to state 153
    LBRACKET        shift and go to state 152


state 133

    (35) condition -> exp comparacion expresion .

    SEMICOLON       reduce using rule 35 (condition -> exp comparacion expresion .)
    COMA            reduce using rule 35 (condition -> exp comparacion expresion .)
    LPAREN          reduce using rule 35 (condition -> exp comparacion expresion .)
    RPAREN          reduce using rule 35 (condition -> exp comparacion expresion .)
    RBRACKET        reduce using rule 35 (condition -> exp comparacion expresion .)


state 134

    (74) exp -> termino signo exp .

    LESSTHAN        reduce using rule 74 (exp -> termino signo exp .)
    MORETHAN        reduce using rule 74 (exp -> termino signo exp .)
    ISEQUAL         reduce using rule 74 (exp -> termino signo exp .)
    NOTEQUAL        reduce using rule 74 (exp -> termino signo exp .)
    AND             reduce using rule 74 (exp -> termino signo exp .)
    OR              reduce using rule 74 (exp -> termino signo exp .)
    SEMICOLON       reduce using rule 74 (exp -> termino signo exp .)
    COMA            reduce using rule 74 (exp -> termino signo exp .)
    LPAREN          reduce using rule 74 (exp -> termino signo exp .)
    RPAREN          reduce using rule 74 (exp -> termino signo exp .)
    RBRACKET        reduce using rule 74 (exp -> termino signo exp .)


state 135

    (85) factor -> functionCall .

    TIMES           reduce using rule 85 (factor -> functionCall .)
    DIVIDE          reduce using rule 85 (factor -> functionCall .)
    DIFF            reduce using rule 85 (factor -> functionCall .)
    EXP             reduce using rule 85 (factor -> functionCall .)
    PLUS            reduce using rule 85 (factor -> functionCall .)
    MINUS           reduce using rule 85 (factor -> functionCall .)
    LESSTHAN        reduce using rule 85 (factor -> functionCall .)
    MORETHAN        reduce using rule 85 (factor -> functionCall .)
    ISEQUAL         reduce using rule 85 (factor -> functionCall .)
    NOTEQUAL        reduce using rule 85 (factor -> functionCall .)
    AND             reduce using rule 85 (factor -> functionCall .)
    OR              reduce using rule 85 (factor -> functionCall .)
    SEMICOLON       reduce using rule 85 (factor -> functionCall .)
    COMA            reduce using rule 85 (factor -> functionCall .)
    LPAREN          reduce using rule 85 (factor -> functionCall .)
    RPAREN          reduce using rule 85 (factor -> functionCall .)
    RBRACKET        reduce using rule 85 (factor -> functionCall .)


state 136

    (100) varcte -> ID .
    (64) funCall -> ID .
    (94) callArr -> ID .

  ! reduce/reduce conflict for LPAREN resolved using rule 64 (funCall -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 64 (funCall -> ID .)
    TIMES           reduce using rule 100 (varcte -> ID .)
    DIVIDE          reduce using rule 100 (varcte -> ID .)
    DIFF            reduce using rule 100 (varcte -> ID .)
    EXP             reduce using rule 100 (varcte -> ID .)
    PLUS            reduce using rule 100 (varcte -> ID .)
    MINUS           reduce using rule 100 (varcte -> ID .)
    LESSTHAN        reduce using rule 100 (varcte -> ID .)
    MORETHAN        reduce using rule 100 (varcte -> ID .)
    ISEQUAL         reduce using rule 100 (varcte -> ID .)
    NOTEQUAL        reduce using rule 100 (varcte -> ID .)
    AND             reduce using rule 100 (varcte -> ID .)
    OR              reduce using rule 100 (varcte -> ID .)
    SEMICOLON       reduce using rule 100 (varcte -> ID .)
    COMA            reduce using rule 100 (varcte -> ID .)
    RBRACKET        reduce using rule 100 (varcte -> ID .)
    LPAREN          reduce using rule 64 (funCall -> ID .)
    RPAREN          reduce using rule 64 (funCall -> ID .)
    LBRACKET        reduce using rule 94 (callArr -> ID .)

  ! LPAREN          [ reduce using rule 100 (varcte -> ID .) ]
  ! RPAREN          [ reduce using rule 100 (varcte -> ID .) ]


state 137

    (83) factor -> paren expresion paren .

    TIMES           reduce using rule 83 (factor -> paren expresion paren .)
    DIVIDE          reduce using rule 83 (factor -> paren expresion paren .)
    DIFF            reduce using rule 83 (factor -> paren expresion paren .)
    EXP             reduce using rule 83 (factor -> paren expresion paren .)
    PLUS            reduce using rule 83 (factor -> paren expresion paren .)
    MINUS           reduce using rule 83 (factor -> paren expresion paren .)
    LESSTHAN        reduce using rule 83 (factor -> paren expresion paren .)
    MORETHAN        reduce using rule 83 (factor -> paren expresion paren .)
    ISEQUAL         reduce using rule 83 (factor -> paren expresion paren .)
    NOTEQUAL        reduce using rule 83 (factor -> paren expresion paren .)
    AND             reduce using rule 83 (factor -> paren expresion paren .)
    OR              reduce using rule 83 (factor -> paren expresion paren .)
    SEMICOLON       reduce using rule 83 (factor -> paren expresion paren .)
    COMA            reduce using rule 83 (factor -> paren expresion paren .)
    LPAREN          reduce using rule 83 (factor -> paren expresion paren .)
    RPAREN          reduce using rule 83 (factor -> paren expresion paren .)
    RBRACKET        reduce using rule 83 (factor -> paren expresion paren .)


state 138

    (78) termino -> factor operacion termino .

    PLUS            reduce using rule 78 (termino -> factor operacion termino .)
    MINUS           reduce using rule 78 (termino -> factor operacion termino .)
    LESSTHAN        reduce using rule 78 (termino -> factor operacion termino .)
    MORETHAN        reduce using rule 78 (termino -> factor operacion termino .)
    ISEQUAL         reduce using rule 78 (termino -> factor operacion termino .)
    NOTEQUAL        reduce using rule 78 (termino -> factor operacion termino .)
    AND             reduce using rule 78 (termino -> factor operacion termino .)
    OR              reduce using rule 78 (termino -> factor operacion termino .)
    SEMICOLON       reduce using rule 78 (termino -> factor operacion termino .)
    COMA            reduce using rule 78 (termino -> factor operacion termino .)
    LPAREN          reduce using rule 78 (termino -> factor operacion termino .)
    RPAREN          reduce using rule 78 (termino -> factor operacion termino .)
    RBRACKET        reduce using rule 78 (termino -> factor operacion termino .)


state 139

    (95) matrix -> openBracket expresion mbracket .

    TIMES           reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    DIVIDE          reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    DIFF            reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    EXP             reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    PLUS            reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    MINUS           reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    LESSTHAN        reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    MORETHAN        reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    ISEQUAL         reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    NOTEQUAL        reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    AND             reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    OR              reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    SEMICOLON       reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    COMA            reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    LPAREN          reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    RPAREN          reduce using rule 95 (matrix -> openBracket expresion mbracket .)
    RBRACKET        reduce using rule 95 (matrix -> openBracket expresion mbracket .)


state 140

    (99) mbracket -> closeBracket .

    TIMES           reduce using rule 99 (mbracket -> closeBracket .)
    DIVIDE          reduce using rule 99 (mbracket -> closeBracket .)
    DIFF            reduce using rule 99 (mbracket -> closeBracket .)
    EXP             reduce using rule 99 (mbracket -> closeBracket .)
    PLUS            reduce using rule 99 (mbracket -> closeBracket .)
    MINUS           reduce using rule 99 (mbracket -> closeBracket .)
    LESSTHAN        reduce using rule 99 (mbracket -> closeBracket .)
    MORETHAN        reduce using rule 99 (mbracket -> closeBracket .)
    ISEQUAL         reduce using rule 99 (mbracket -> closeBracket .)
    NOTEQUAL        reduce using rule 99 (mbracket -> closeBracket .)
    AND             reduce using rule 99 (mbracket -> closeBracket .)
    OR              reduce using rule 99 (mbracket -> closeBracket .)
    SEMICOLON       reduce using rule 99 (mbracket -> closeBracket .)
    COMA            reduce using rule 99 (mbracket -> closeBracket .)
    LPAREN          reduce using rule 99 (mbracket -> closeBracket .)
    RPAREN          reduce using rule 99 (mbracket -> closeBracket .)
    RBRACKET        reduce using rule 99 (mbracket -> closeBracket .)


state 141

    (97) closeBracket -> RBRACKET .

    TIMES           reduce using rule 97 (closeBracket -> RBRACKET .)
    DIVIDE          reduce using rule 97 (closeBracket -> RBRACKET .)
    DIFF            reduce using rule 97 (closeBracket -> RBRACKET .)
    EXP             reduce using rule 97 (closeBracket -> RBRACKET .)
    PLUS            reduce using rule 97 (closeBracket -> RBRACKET .)
    MINUS           reduce using rule 97 (closeBracket -> RBRACKET .)
    LESSTHAN        reduce using rule 97 (closeBracket -> RBRACKET .)
    MORETHAN        reduce using rule 97 (closeBracket -> RBRACKET .)
    ISEQUAL         reduce using rule 97 (closeBracket -> RBRACKET .)
    NOTEQUAL        reduce using rule 97 (closeBracket -> RBRACKET .)
    AND             reduce using rule 97 (closeBracket -> RBRACKET .)
    OR              reduce using rule 97 (closeBracket -> RBRACKET .)
    SEMICOLON       reduce using rule 97 (closeBracket -> RBRACKET .)
    COMA            reduce using rule 97 (closeBracket -> RBRACKET .)
    LPAREN          reduce using rule 97 (closeBracket -> RBRACKET .)
    RPAREN          reduce using rule 97 (closeBracket -> RBRACKET .)
    RBRACKET        reduce using rule 97 (closeBracket -> RBRACKET .)
    LBRACKET        reduce using rule 97 (closeBracket -> RBRACKET .)


state 142

    (92) arr -> callArr openBracket expresion . abracket matrix
    (93) arr -> callArr openBracket expresion . abracket epsilon
    (98) abracket -> . closeBracket
    (97) closeBracket -> . RBRACKET

    RBRACKET        shift and go to state 141

    abracket                       shift and go to state 154
    closeBracket                   shift and go to state 155

state 143

    (48) condicion -> IF LPAREN expresion endCondition bloque . condicionelse
    (51) condicionelse -> . else bloque
    (52) condicionelse -> . epsilon
    (53) else -> . ELSE
    (88) epsilon -> .

    ELSE            shift and go to state 159
    SEMICOLON       reduce using rule 88 (epsilon -> .)

    condicionelse                  shift and go to state 156
    else                           shift and go to state 157
    epsilon                        shift and go to state 158

state 144

    (44) whileLoop -> WHILE startCondition expresion endCondition bloque .

    SEMICOLON       reduce using rule 44 (whileLoop -> WHILE startCondition expresion endCondition bloque .)


state 145

    (42) doWhile -> do bloque WHILE LPAREN expresion . RPAREN

    RPAREN          shift and go to state 160


state 146

    (47) forLoop -> FOR LPAREN argumentos startCondition expresion . endCondition asignacion RPAREN bloque
    (49) endCondition -> . RPAREN
    (50) endCondition -> . SEMICOLON

    RPAREN          shift and go to state 120
    SEMICOLON       shift and go to state 121

    endCondition                   shift and go to state 161

state 147

    (72) args -> args COMA args .
    (72) args -> args . COMA args

  ! shift/reduce conflict for COMA resolved as shift
    LPAREN          reduce using rule 72 (args -> args COMA args .)
    SEMICOLON       reduce using rule 72 (args -> args COMA args .)
    COMA            shift and go to state 125

  ! COMA            [ reduce using rule 72 (args -> args COMA args .) ]


state 148

    (30) escrito -> impr COMA impr .

    RPAREN          reduce using rule 30 (escrito -> impr COMA impr .)


state 149

    (54) funcion -> FUNCTION funcdef LPAREN declaracion addArgs . RPAREN COLON tiposreturn

    RPAREN          shift and go to state 162


state 150

    (55) addArgs -> epsilon .

    RPAREN          reduce using rule 55 (addArgs -> epsilon .)


state 151

    (66) funcArgs -> funcArgs COMA funcArgs .
    (66) funcArgs -> funcArgs . COMA funcArgs

  ! shift/reduce conflict for COMA resolved as shift
    LPAREN          reduce using rule 66 (funcArgs -> funcArgs COMA funcArgs .)
    RPAREN          reduce using rule 66 (funcArgs -> funcArgs COMA funcArgs .)
    COMA            shift and go to state 130

  ! COMA            [ reduce using rule 66 (funcArgs -> funcArgs COMA funcArgs .) ]


state 152

    (91) declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET . INT RBRACKET COLON tipo

    INT             shift and go to state 163


state 153

    (90) declaracionArr -> arrDef LBRACKET INT RBRACKET COLON . tipo
    (10) tipo -> . INT
    (11) tipo -> . FLOAT
    (12) tipo -> . BOOL
    (13) tipo -> . STRING

    INT             shift and go to state 96
    FLOAT           shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99

    tipo                           shift and go to state 164

state 154

    (92) arr -> callArr openBracket expresion abracket . matrix
    (93) arr -> callArr openBracket expresion abracket . epsilon
    (95) matrix -> . openBracket expresion mbracket
    (88) epsilon -> .
    (96) openBracket -> . LBRACKET

    TIMES           reduce using rule 88 (epsilon -> .)
    DIVIDE          reduce using rule 88 (epsilon -> .)
    DIFF            reduce using rule 88 (epsilon -> .)
    EXP             reduce using rule 88 (epsilon -> .)
    PLUS            reduce using rule 88 (epsilon -> .)
    MINUS           reduce using rule 88 (epsilon -> .)
    LESSTHAN        reduce using rule 88 (epsilon -> .)
    MORETHAN        reduce using rule 88 (epsilon -> .)
    ISEQUAL         reduce using rule 88 (epsilon -> .)
    NOTEQUAL        reduce using rule 88 (epsilon -> .)
    AND             reduce using rule 88 (epsilon -> .)
    OR              reduce using rule 88 (epsilon -> .)
    SEMICOLON       reduce using rule 88 (epsilon -> .)
    COMA            reduce using rule 88 (epsilon -> .)
    LPAREN          reduce using rule 88 (epsilon -> .)
    RPAREN          reduce using rule 88 (epsilon -> .)
    RBRACKET        reduce using rule 88 (epsilon -> .)
    LBRACKET        shift and go to state 78

    openBracket                    shift and go to state 76
    matrix                         shift and go to state 165
    epsilon                        shift and go to state 166

state 155

    (98) abracket -> closeBracket .

    LBRACKET        reduce using rule 98 (abracket -> closeBracket .)
    TIMES           reduce using rule 98 (abracket -> closeBracket .)
    DIVIDE          reduce using rule 98 (abracket -> closeBracket .)
    DIFF            reduce using rule 98 (abracket -> closeBracket .)
    EXP             reduce using rule 98 (abracket -> closeBracket .)
    PLUS            reduce using rule 98 (abracket -> closeBracket .)
    MINUS           reduce using rule 98 (abracket -> closeBracket .)
    LESSTHAN        reduce using rule 98 (abracket -> closeBracket .)
    MORETHAN        reduce using rule 98 (abracket -> closeBracket .)
    ISEQUAL         reduce using rule 98 (abracket -> closeBracket .)
    NOTEQUAL        reduce using rule 98 (abracket -> closeBracket .)
    AND             reduce using rule 98 (abracket -> closeBracket .)
    OR              reduce using rule 98 (abracket -> closeBracket .)
    SEMICOLON       reduce using rule 98 (abracket -> closeBracket .)
    COMA            reduce using rule 98 (abracket -> closeBracket .)
    LPAREN          reduce using rule 98 (abracket -> closeBracket .)
    RPAREN          reduce using rule 98 (abracket -> closeBracket .)
    RBRACKET        reduce using rule 98 (abracket -> closeBracket .)


state 156

    (48) condicion -> IF LPAREN expresion endCondition bloque condicionelse .

    SEMICOLON       reduce using rule 48 (condicion -> IF LPAREN expresion endCondition bloque condicionelse .)


state 157

    (51) condicionelse -> else . bloque
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 167

state 158

    (52) condicionelse -> epsilon .

    SEMICOLON       reduce using rule 52 (condicionelse -> epsilon .)


state 159

    (53) else -> ELSE .

    LCURLY          reduce using rule 53 (else -> ELSE .)


state 160

    (42) doWhile -> do bloque WHILE LPAREN expresion RPAREN .

    SEMICOLON       reduce using rule 42 (doWhile -> do bloque WHILE LPAREN expresion RPAREN .)


state 161

    (47) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition . asignacion RPAREN bloque
    (27) asignacion -> . ID EQUAL expresion

    ID              shift and go to state 86

    asignacion                     shift and go to state 168

state 162

    (54) funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN . COLON tiposreturn

    COLON           shift and go to state 169


state 163

    (91) declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT . RBRACKET COLON tipo

    RBRACKET        shift and go to state 170


state 164

    (90) declaracionArr -> arrDef LBRACKET INT RBRACKET COLON tipo .

    SEMICOLON       reduce using rule 90 (declaracionArr -> arrDef LBRACKET INT RBRACKET COLON tipo .)


state 165

    (92) arr -> callArr openBracket expresion abracket matrix .

    TIMES           reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    DIVIDE          reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    DIFF            reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    EXP             reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    PLUS            reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    MINUS           reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    LESSTHAN        reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    MORETHAN        reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    ISEQUAL         reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    NOTEQUAL        reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    AND             reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    OR              reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    SEMICOLON       reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    COMA            reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    LPAREN          reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    RPAREN          reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)
    RBRACKET        reduce using rule 92 (arr -> callArr openBracket expresion abracket matrix .)


state 166

    (93) arr -> callArr openBracket expresion abracket epsilon .

    TIMES           reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    DIVIDE          reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    DIFF            reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    EXP             reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    PLUS            reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    MINUS           reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    LESSTHAN        reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    MORETHAN        reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    ISEQUAL         reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    NOTEQUAL        reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    AND             reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    OR              reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    SEMICOLON       reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    COMA            reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    LPAREN          reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    RPAREN          reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)
    RBRACKET        reduce using rule 93 (arr -> callArr openBracket expresion abracket epsilon .)


state 167

    (51) condicionelse -> else bloque .

    SEMICOLON       reduce using rule 51 (condicionelse -> else bloque .)


state 168

    (47) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion . RPAREN bloque

    RPAREN          shift and go to state 171


state 169

    (54) funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON . tiposreturn
    (57) tiposreturn -> . tiposFuncion bloqueReturn
    (58) tiposreturn -> . VOID bloque
    (59) tiposFuncion -> . INT
    (60) tiposFuncion -> . FLOAT
    (61) tiposFuncion -> . BOOL
    (62) tiposFuncion -> . STRING

    VOID            shift and go to state 174
    INT             shift and go to state 175
    FLOAT           shift and go to state 176
    BOOL            shift and go to state 177
    STRING          shift and go to state 178

    tiposreturn                    shift and go to state 172
    tiposFuncion                   shift and go to state 173

state 170

    (91) declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET . COLON tipo

    COLON           shift and go to state 179


state 171

    (47) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN . bloque
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 180

state 172

    (54) funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn .

    SEMICOLON       reduce using rule 54 (funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn .)


state 173

    (57) tiposreturn -> tiposFuncion . bloqueReturn
    (15) bloqueReturn -> . LCURLY declaracion estatutoExp returnexp RCURLY

    LCURLY          shift and go to state 182

    bloqueReturn                   shift and go to state 181

state 174

    (58) tiposreturn -> VOID . bloque
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 183

state 175

    (59) tiposFuncion -> INT .

    LCURLY          reduce using rule 59 (tiposFuncion -> INT .)


state 176

    (60) tiposFuncion -> FLOAT .

    LCURLY          reduce using rule 60 (tiposFuncion -> FLOAT .)


state 177

    (61) tiposFuncion -> BOOL .

    LCURLY          reduce using rule 61 (tiposFuncion -> BOOL .)


state 178

    (62) tiposFuncion -> STRING .

    LCURLY          reduce using rule 62 (tiposFuncion -> STRING .)


state 179

    (91) declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON . tipo
    (10) tipo -> . INT
    (11) tipo -> . FLOAT
    (12) tipo -> . BOOL
    (13) tipo -> . STRING

    INT             shift and go to state 96
    FLOAT           shift and go to state 97
    BOOL            shift and go to state 98
    STRING          shift and go to state 99

    tipo                           shift and go to state 184

state 180

    (47) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque .

    SEMICOLON       reduce using rule 47 (forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque .)


state 181

    (57) tiposreturn -> tiposFuncion bloqueReturn .

    SEMICOLON       reduce using rule 57 (tiposreturn -> tiposFuncion bloqueReturn .)


state 182

    (15) bloqueReturn -> LCURLY . declaracion estatutoExp returnexp RCURLY
    (2) declaracion -> . vars
    (3) declaracion -> . epsilon
    (4) vars -> . VAR var
    (5) vars -> . vars vars
    (88) epsilon -> .

    VAR             shift and go to state 10
    ID              reduce using rule 88 (epsilon -> .)
    IF              reduce using rule 88 (epsilon -> .)
    WHILE           reduce using rule 88 (epsilon -> .)
    FOR             reduce using rule 88 (epsilon -> .)
    PRINT           reduce using rule 88 (epsilon -> .)
    FUNCTION        reduce using rule 88 (epsilon -> .)
    DO              reduce using rule 88 (epsilon -> .)

    declaracion                    shift and go to state 185
    vars                           shift and go to state 8
    epsilon                        shift and go to state 9

state 183

    (58) tiposreturn -> VOID bloque .

    SEMICOLON       reduce using rule 58 (tiposreturn -> VOID bloque .)


state 184

    (91) declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON tipo .

    SEMICOLON       reduce using rule 91 (declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON tipo .)


state 185

    (15) bloqueReturn -> LCURLY declaracion . estatutoExp returnexp RCURLY
    (16) estatutoExp -> . estatuto SEMICOLON
    (17) estatutoExp -> . estatutoExp estatutoExp
    (18) estatuto -> . asignacion
    (19) estatuto -> . condicion
    (20) estatuto -> . whileLoop
    (21) estatuto -> . doWhile
    (22) estatuto -> . forLoop
    (23) estatuto -> . escritura
    (24) estatuto -> . funcion
    (25) estatuto -> . functionCall
    (27) asignacion -> . ID EQUAL expresion
    (48) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (44) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (42) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (47) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (28) escritura -> . PRINT LPAREN escrito RPAREN
    (54) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (63) functionCall -> . funCall paren funcArgs paren
    (43) do -> . DO
    (64) funCall -> . ID

    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    FUNCTION        shift and go to state 27
    DO              shift and go to state 29

    estatutoExp                    shift and go to state 186
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    condicion                      shift and go to state 14
    whileLoop                      shift and go to state 15
    doWhile                        shift and go to state 16
    forLoop                        shift and go to state 17
    escritura                      shift and go to state 18
    funcion                        shift and go to state 19
    functionCall                   shift and go to state 20
    do                             shift and go to state 24
    funCall                        shift and go to state 28

state 186

    (15) bloqueReturn -> LCURLY declaracion estatutoExp . returnexp RCURLY
    (17) estatutoExp -> estatutoExp . estatutoExp
    (26) returnexp -> . RETURN expresion SEMICOLON
    (16) estatutoExp -> . estatuto SEMICOLON
    (17) estatutoExp -> . estatutoExp estatutoExp
    (18) estatuto -> . asignacion
    (19) estatuto -> . condicion
    (20) estatuto -> . whileLoop
    (21) estatuto -> . doWhile
    (22) estatuto -> . forLoop
    (23) estatuto -> . escritura
    (24) estatuto -> . funcion
    (25) estatuto -> . functionCall
    (27) asignacion -> . ID EQUAL expresion
    (48) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (44) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (42) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (47) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (28) escritura -> . PRINT LPAREN escrito RPAREN
    (54) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (63) functionCall -> . funCall paren funcArgs paren
    (43) do -> . DO
    (64) funCall -> . ID

    RETURN          shift and go to state 188
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    FUNCTION        shift and go to state 27
    DO              shift and go to state 29

    estatutoExp                    shift and go to state 37
    returnexp                      shift and go to state 187
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    condicion                      shift and go to state 14
    whileLoop                      shift and go to state 15
    doWhile                        shift and go to state 16
    forLoop                        shift and go to state 17
    escritura                      shift and go to state 18
    funcion                        shift and go to state 19
    functionCall                   shift and go to state 20
    do                             shift and go to state 24
    funCall                        shift and go to state 28

state 187

    (15) bloqueReturn -> LCURLY declaracion estatutoExp returnexp . RCURLY

    RCURLY          shift and go to state 189


state 188

    (26) returnexp -> RETURN . expresion SEMICOLON
    (32) expresion -> . exp
    (33) expresion -> . condition
    (34) expresion -> . functionCall
    (73) exp -> . termino
    (74) exp -> . termino signo exp
    (35) condition -> . exp comparacion expresion
    (63) functionCall -> . funCall paren funcArgs paren
    (77) termino -> . factor
    (78) termino -> . factor operacion termino
    (64) funCall -> . ID
    (83) factor -> . paren expresion paren
    (84) factor -> . varcte
    (85) factor -> . functionCall
    (86) paren -> . LPAREN
    (87) paren -> . RPAREN
    (100) varcte -> . ID
    (101) varcte -> . int
    (102) varcte -> . float
    (103) varcte -> . bool
    (104) varcte -> . string
    (105) varcte -> . matrix
    (106) varcte -> . arr
    (107) int -> . INT
    (108) float -> . FLOAT
    (109) bool -> . BOOL
    (110) string -> . STRING
    (95) matrix -> . openBracket expresion mbracket
    (92) arr -> . callArr openBracket expresion abracket matrix
    (93) arr -> . callArr openBracket expresion abracket epsilon
    (96) openBracket -> . LBRACKET
    (94) callArr -> . ID

    ID              shift and go to state 57
    LPAREN          shift and go to state 51
    RPAREN          shift and go to state 52
    INT             shift and go to state 72
    FLOAT           shift and go to state 73
    BOOL            shift and go to state 74
    STRING          shift and go to state 75
    LBRACKET        shift and go to state 78

    expresion                      shift and go to state 190
    exp                            shift and go to state 59
    condition                      shift and go to state 60
    functionCall                   shift and go to state 61
    termino                        shift and go to state 62
    funCall                        shift and go to state 28
    paren                          shift and go to state 63
    factor                         shift and go to state 64
    varcte                         shift and go to state 65
    int                            shift and go to state 66
    float                          shift and go to state 67
    bool                           shift and go to state 68
    string                         shift and go to state 69
    matrix                         shift and go to state 70
    arr                            shift and go to state 71
    openBracket                    shift and go to state 76
    callArr                        shift and go to state 77

state 189

    (15) bloqueReturn -> LCURLY declaracion estatutoExp returnexp RCURLY .

    SEMICOLON       reduce using rule 15 (bloqueReturn -> LCURLY declaracion estatutoExp returnexp RCURLY .)


state 190

    (26) returnexp -> RETURN expresion . SEMICOLON

    SEMICOLON       shift and go to state 191


state 191

    (26) returnexp -> RETURN expresion SEMICOLON .

    RCURLY          reduce using rule 26 (returnexp -> RETURN expresion SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VAR in state 30 resolved as shift
WARNING: shift/reduce conflict for ID in state 37 resolved as shift
WARNING: shift/reduce conflict for IF in state 37 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 37 resolved as shift
WARNING: shift/reduce conflict for FOR in state 37 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 37 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 37 resolved as shift
WARNING: shift/reduce conflict for DO in state 37 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 50 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 50 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 130 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 130 resolved as shift
WARNING: shift/reduce conflict for COMA in state 147 resolved as shift
WARNING: shift/reduce conflict for COMA in state 151 resolved as shift
WARNING: reduce/reduce conflict in state 57 resolved using rule (funCall -> ID)
WARNING: rejected rule (varcte -> ID) in state 57
WARNING: reduce/reduce conflict in state 61 resolved using rule (expresion -> functionCall)
WARNING: rejected rule (factor -> functionCall) in state 61
WARNING: reduce/reduce conflict in state 136 resolved using rule (funCall -> ID)
WARNING: rejected rule (varcte -> ID) in state 136
