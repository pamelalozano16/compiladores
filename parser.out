Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CTEF
    CTEL

Grammar

Rule 0     S' -> programa
Rule 1     programa -> START LPAREN RPAREN bloque
Rule 2     declaracion -> vars
Rule 3     declaracion -> epsilon
Rule 4     vars -> VAR var
Rule 5     vars -> vars vars
Rule 6     var -> vardef COLON tipo SEMICOLON
Rule 7     vardef -> ID
Rule 8     tipo -> INT
Rule 9     tipo -> FLOAT
Rule 10    tipo -> BOOL
Rule 11    tipo -> STRING
Rule 12    lista -> ID
Rule 13    lista -> ID COMA
Rule 14    arreglo -> LBRACKET lista RBRACKET
Rule 15    bloque -> LCURLY declaracion estatutoExp RCURLY
Rule 16    bloqueReturn -> LCURLY declaracion estatutoExp returnexp RCURLY
Rule 17    estatutoExp -> estatuto SEMICOLON
Rule 18    estatutoExp -> estatutoExp estatutoExp
Rule 19    estatuto -> asignacion
Rule 20    estatuto -> condicion
Rule 21    estatuto -> whileLoop
Rule 22    estatuto -> doWhile
Rule 23    estatuto -> forLoop
Rule 24    estatuto -> escritura
Rule 25    estatuto -> funcion
Rule 26    estatuto -> functionCall
Rule 27    returnexp -> RETURN expresion SEMICOLON
Rule 28    asignacion -> ID EQUAL expresion
Rule 29    escritura -> PRINT LPAREN escrito RPAREN
Rule 30    escrito -> impr
Rule 31    escrito -> impr COMA impr
Rule 32    impr -> STRING
Rule 33    impr -> expresion
Rule 34    expresion -> exp
Rule 35    expresion -> condition
Rule 36    expresion -> arreglo
Rule 37    expresion -> functionCall
Rule 38    condition -> exp comparacion expresion
Rule 39    comparacion -> LESSTHAN
Rule 40    comparacion -> MORETHAN
Rule 41    comparacion -> ISEQUAL
Rule 42    comparacion -> NOTEQUAL
Rule 43    comparacion -> AND
Rule 44    comparacion -> OR
Rule 45    doWhile -> do bloque WHILE LPAREN expresion RPAREN
Rule 46    do -> DO
Rule 47    whileLoop -> WHILE startCondition expresion endCondition bloque
Rule 48    startCondition -> LPAREN
Rule 49    startCondition -> SEMICOLON
Rule 50    forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
Rule 51    condicion -> IF LPAREN expresion endCondition bloque condicionelse
Rule 52    endCondition -> RPAREN
Rule 53    endCondition -> SEMICOLON
Rule 54    condicionelse -> else bloque
Rule 55    condicionelse -> epsilon
Rule 56    else -> ELSE
Rule 57    funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
Rule 58    addArgs -> epsilon
Rule 59    funcdef -> ID
Rule 60    tiposreturn -> tiposFuncion bloqueReturn
Rule 61    tiposreturn -> VOID bloque
Rule 62    tiposFuncion -> INT
Rule 63    tiposFuncion -> FLOAT
Rule 64    tiposFuncion -> BOOL
Rule 65    tiposFuncion -> STRING
Rule 66    functionCall -> funCall paren funcArgs paren
Rule 67    funCall -> ID
Rule 68    funcArgs -> checkArgs
Rule 69    funcArgs -> funcArgs COMA funcArgs
Rule 70    funcArgs -> epsilon
Rule 71    checkArgs -> expresion
Rule 72    argumentos -> args
Rule 73    argumentos -> epsilon
Rule 74    args -> asignacion
Rule 75    args -> args COMA args
Rule 76    exp -> termino
Rule 77    exp -> termino signo exp
Rule 78    signo -> PLUS
Rule 79    signo -> MINUS
Rule 80    termino -> factor
Rule 81    termino -> factor operacion termino
Rule 82    operacion -> TIMES
Rule 83    operacion -> DIVIDE
Rule 84    operacion -> DIFF
Rule 85    operacion -> EXP
Rule 86    factor -> paren expresion paren
Rule 87    factor -> varcte
Rule 88    factor -> functionCall
Rule 89    paren -> LPAREN
Rule 90    paren -> RPAREN
Rule 91    epsilon -> <empty>
Rule 92    varcte -> ID
Rule 93    varcte -> int
Rule 94    varcte -> float
Rule 95    varcte -> bool
Rule 96    varcte -> string
Rule 97    int -> INT
Rule 98    float -> FLOAT
Rule 99    bool -> BOOL
Rule 100   string -> STRING

Terminals, with rules where they appear

AND                  : 43
BOOL                 : 10 64 99
COLON                : 6 57
COMA                 : 13 31 69 75
CTEF                 : 
CTEL                 : 
DIFF                 : 84
DIVIDE               : 83
DO                   : 46
ELSE                 : 56
EQUAL                : 28
EXP                  : 85
FLOAT                : 9 63 98
FOR                  : 50
FUNCTION             : 57
ID                   : 7 12 13 28 59 67 92
IF                   : 51
INT                  : 8 62 97
ISEQUAL              : 41
LBRACKET             : 14
LCURLY               : 15 16
LESSTHAN             : 39
LPAREN               : 1 29 45 48 50 51 57 89
MINUS                : 79
MORETHAN             : 40
NOTEQUAL             : 42
OR                   : 44
PLUS                 : 78
PRINT                : 29
RBRACKET             : 14
RCURLY               : 15 16
RETURN               : 27
RPAREN               : 1 29 45 50 52 57 90
SEMICOLON            : 6 17 27 49 53
START                : 1
STRING               : 11 32 65 100
TIMES                : 82
VAR                  : 4
VOID                 : 61
WHILE                : 45 47
error                : 

Nonterminals, with rules where they appear

addArgs              : 57
args                 : 72 75 75
argumentos           : 50
arreglo              : 36
asignacion           : 19 50 74
bloque               : 1 45 47 50 51 54 61
bloqueReturn         : 60
bool                 : 95
checkArgs            : 68
comparacion          : 38
condicion            : 20
condicionelse        : 51
condition            : 35
declaracion          : 15 16 57
do                   : 45
doWhile              : 22
else                 : 54
endCondition         : 47 50 51
epsilon              : 3 55 58 70 73
escrito              : 29
escritura            : 24
estatuto             : 17
estatutoExp          : 15 16 18 18
exp                  : 34 38 77
expresion            : 27 28 33 38 45 47 50 51 71 86
factor               : 80 81
float                : 94
forLoop              : 23
funCall              : 66
funcArgs             : 66 69 69
funcdef              : 57
funcion              : 25
functionCall         : 26 37 88
impr                 : 30 31 31
int                  : 93
lista                : 14
operacion            : 81
paren                : 66 66 86 86
programa             : 0
returnexp            : 16
signo                : 77
startCondition       : 47 50
string               : 96
termino              : 76 77 81
tipo                 : 6
tiposFuncion         : 60
tiposreturn          : 57
var                  : 4
varcte               : 87
vardef               : 6
vars                 : 2 5 5
whileLoop            : 21

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . START LPAREN RPAREN bloque

    START           shift and go to state 2

    programa                       shift and go to state 1

state 1

    (0) S' -> programa .



state 2

    (1) programa -> START . LPAREN RPAREN bloque

    LPAREN          shift and go to state 3


state 3

    (1) programa -> START LPAREN . RPAREN bloque

    RPAREN          shift and go to state 4


state 4

    (1) programa -> START LPAREN RPAREN . bloque
    (15) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 5

state 5

    (1) programa -> START LPAREN RPAREN bloque .

    $end            reduce using rule 1 (programa -> START LPAREN RPAREN bloque .)


state 6

    (15) bloque -> LCURLY . declaracion estatutoExp RCURLY
    (2) declaracion -> . vars
    (3) declaracion -> . epsilon
    (4) vars -> . VAR var
    (5) vars -> . vars vars
    (91) epsilon -> .

    VAR             shift and go to state 10
    ID              reduce using rule 91 (epsilon -> .)
    IF              reduce using rule 91 (epsilon -> .)
    WHILE           reduce using rule 91 (epsilon -> .)
    FOR             reduce using rule 91 (epsilon -> .)
    PRINT           reduce using rule 91 (epsilon -> .)
    FUNCTION        reduce using rule 91 (epsilon -> .)
    DO              reduce using rule 91 (epsilon -> .)

    declaracion                    shift and go to state 7
    vars                           shift and go to state 8
    epsilon                        shift and go to state 9

state 7

    (15) bloque -> LCURLY declaracion . estatutoExp RCURLY
    (17) estatutoExp -> . estatuto SEMICOLON
    (18) estatutoExp -> . estatutoExp estatutoExp
    (19) estatuto -> . asignacion
    (20) estatuto -> . condicion
    (21) estatuto -> . whileLoop
    (22) estatuto -> . doWhile
    (23) estatuto -> . forLoop
    (24) estatuto -> . escritura
    (25) estatuto -> . funcion
    (26) estatuto -> . functionCall
    (28) asignacion -> . ID EQUAL expresion
    (51) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (47) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (45) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (50) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (29) escritura -> . PRINT LPAREN escrito RPAREN
    (57) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (66) functionCall -> . funCall paren funcArgs paren
    (46) do -> . DO
    (67) funCall -> . ID

    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    FUNCTION        shift and go to state 27
    DO              shift and go to state 29

    estatutoExp                    shift and go to state 11
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    condicion                      shift and go to state 14
    whileLoop                      shift and go to state 15
    doWhile                        shift and go to state 16
    forLoop                        shift and go to state 17
    escritura                      shift and go to state 18
    funcion                        shift and go to state 19
    functionCall                   shift and go to state 20
    do                             shift and go to state 24
    funCall                        shift and go to state 28

state 8

    (2) declaracion -> vars .
    (5) vars -> vars . vars
    (4) vars -> . VAR var
    (5) vars -> . vars vars

    ID              reduce using rule 2 (declaracion -> vars .)
    IF              reduce using rule 2 (declaracion -> vars .)
    WHILE           reduce using rule 2 (declaracion -> vars .)
    FOR             reduce using rule 2 (declaracion -> vars .)
    PRINT           reduce using rule 2 (declaracion -> vars .)
    FUNCTION        reduce using rule 2 (declaracion -> vars .)
    DO              reduce using rule 2 (declaracion -> vars .)
    RPAREN          reduce using rule 2 (declaracion -> vars .)
    VAR             shift and go to state 10

    vars                           shift and go to state 30

state 9

    (3) declaracion -> epsilon .

    ID              reduce using rule 3 (declaracion -> epsilon .)
    IF              reduce using rule 3 (declaracion -> epsilon .)
    WHILE           reduce using rule 3 (declaracion -> epsilon .)
    FOR             reduce using rule 3 (declaracion -> epsilon .)
    PRINT           reduce using rule 3 (declaracion -> epsilon .)
    FUNCTION        reduce using rule 3 (declaracion -> epsilon .)
    DO              reduce using rule 3 (declaracion -> epsilon .)
    RPAREN          reduce using rule 3 (declaracion -> epsilon .)


state 10

    (4) vars -> VAR . var
    (6) var -> . vardef COLON tipo SEMICOLON
    (7) vardef -> . ID

    ID              shift and go to state 33

    var                            shift and go to state 31
    vardef                         shift and go to state 32

state 11

    (15) bloque -> LCURLY declaracion estatutoExp . RCURLY
    (18) estatutoExp -> estatutoExp . estatutoExp
    (17) estatutoExp -> . estatuto SEMICOLON
    (18) estatutoExp -> . estatutoExp estatutoExp
    (19) estatuto -> . asignacion
    (20) estatuto -> . condicion
    (21) estatuto -> . whileLoop
    (22) estatuto -> . doWhile
    (23) estatuto -> . forLoop
    (24) estatuto -> . escritura
    (25) estatuto -> . funcion
    (26) estatuto -> . functionCall
    (28) asignacion -> . ID EQUAL expresion
    (51) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (47) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (45) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (50) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (29) escritura -> . PRINT LPAREN escrito RPAREN
    (57) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (66) functionCall -> . funCall paren funcArgs paren
    (46) do -> . DO
    (67) funCall -> . ID

    RCURLY          shift and go to state 35
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    FUNCTION        shift and go to state 27
    DO              shift and go to state 29

    estatutoExp                    shift and go to state 34
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    condicion                      shift and go to state 14
    whileLoop                      shift and go to state 15
    doWhile                        shift and go to state 16
    forLoop                        shift and go to state 17
    escritura                      shift and go to state 18
    funcion                        shift and go to state 19
    functionCall                   shift and go to state 20
    do                             shift and go to state 24
    funCall                        shift and go to state 28

state 12

    (17) estatutoExp -> estatuto . SEMICOLON

    SEMICOLON       shift and go to state 36


state 13

    (19) estatuto -> asignacion .

    SEMICOLON       reduce using rule 19 (estatuto -> asignacion .)


state 14

    (20) estatuto -> condicion .

    SEMICOLON       reduce using rule 20 (estatuto -> condicion .)


state 15

    (21) estatuto -> whileLoop .

    SEMICOLON       reduce using rule 21 (estatuto -> whileLoop .)


state 16

    (22) estatuto -> doWhile .

    SEMICOLON       reduce using rule 22 (estatuto -> doWhile .)


state 17

    (23) estatuto -> forLoop .

    SEMICOLON       reduce using rule 23 (estatuto -> forLoop .)


state 18

    (24) estatuto -> escritura .

    SEMICOLON       reduce using rule 24 (estatuto -> escritura .)


state 19

    (25) estatuto -> funcion .

    SEMICOLON       reduce using rule 25 (estatuto -> funcion .)


state 20

    (26) estatuto -> functionCall .

    SEMICOLON       reduce using rule 26 (estatuto -> functionCall .)


state 21

    (28) asignacion -> ID . EQUAL expresion
    (67) funCall -> ID .

    EQUAL           shift and go to state 37
    LPAREN          reduce using rule 67 (funCall -> ID .)
    RPAREN          reduce using rule 67 (funCall -> ID .)


state 22

    (51) condicion -> IF . LPAREN expresion endCondition bloque condicionelse

    LPAREN          shift and go to state 38


state 23

    (47) whileLoop -> WHILE . startCondition expresion endCondition bloque
    (48) startCondition -> . LPAREN
    (49) startCondition -> . SEMICOLON

    LPAREN          shift and go to state 40
    SEMICOLON       shift and go to state 41

    startCondition                 shift and go to state 39

state 24

    (45) doWhile -> do . bloque WHILE LPAREN expresion RPAREN
    (15) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 42

state 25

    (50) forLoop -> FOR . LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque

    LPAREN          shift and go to state 43


state 26

    (29) escritura -> PRINT . LPAREN escrito RPAREN

    LPAREN          shift and go to state 44


state 27

    (57) funcion -> FUNCTION . funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (59) funcdef -> . ID

    ID              shift and go to state 46

    funcdef                        shift and go to state 45

state 28

    (66) functionCall -> funCall . paren funcArgs paren
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN

    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49

    paren                          shift and go to state 47

state 29

    (46) do -> DO .

    LCURLY          reduce using rule 46 (do -> DO .)


state 30

    (5) vars -> vars vars .
    (5) vars -> vars . vars
    (4) vars -> . VAR var
    (5) vars -> . vars vars

  ! shift/reduce conflict for VAR resolved as shift
    ID              reduce using rule 5 (vars -> vars vars .)
    IF              reduce using rule 5 (vars -> vars vars .)
    WHILE           reduce using rule 5 (vars -> vars vars .)
    FOR             reduce using rule 5 (vars -> vars vars .)
    PRINT           reduce using rule 5 (vars -> vars vars .)
    FUNCTION        reduce using rule 5 (vars -> vars vars .)
    DO              reduce using rule 5 (vars -> vars vars .)
    RPAREN          reduce using rule 5 (vars -> vars vars .)
    VAR             shift and go to state 10

  ! VAR             [ reduce using rule 5 (vars -> vars vars .) ]

    vars                           shift and go to state 30

state 31

    (4) vars -> VAR var .

    VAR             reduce using rule 4 (vars -> VAR var .)
    ID              reduce using rule 4 (vars -> VAR var .)
    IF              reduce using rule 4 (vars -> VAR var .)
    WHILE           reduce using rule 4 (vars -> VAR var .)
    FOR             reduce using rule 4 (vars -> VAR var .)
    PRINT           reduce using rule 4 (vars -> VAR var .)
    FUNCTION        reduce using rule 4 (vars -> VAR var .)
    DO              reduce using rule 4 (vars -> VAR var .)
    RPAREN          reduce using rule 4 (vars -> VAR var .)


state 32

    (6) var -> vardef . COLON tipo SEMICOLON

    COLON           shift and go to state 50


state 33

    (7) vardef -> ID .

    COLON           reduce using rule 7 (vardef -> ID .)


state 34

    (18) estatutoExp -> estatutoExp estatutoExp .
    (18) estatutoExp -> estatutoExp . estatutoExp
    (17) estatutoExp -> . estatuto SEMICOLON
    (18) estatutoExp -> . estatutoExp estatutoExp
    (19) estatuto -> . asignacion
    (20) estatuto -> . condicion
    (21) estatuto -> . whileLoop
    (22) estatuto -> . doWhile
    (23) estatuto -> . forLoop
    (24) estatuto -> . escritura
    (25) estatuto -> . funcion
    (26) estatuto -> . functionCall
    (28) asignacion -> . ID EQUAL expresion
    (51) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (47) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (45) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (50) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (29) escritura -> . PRINT LPAREN escrito RPAREN
    (57) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (66) functionCall -> . funCall paren funcArgs paren
    (46) do -> . DO
    (67) funCall -> . ID

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    RCURLY          reduce using rule 18 (estatutoExp -> estatutoExp estatutoExp .)
    RETURN          reduce using rule 18 (estatutoExp -> estatutoExp estatutoExp .)
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    FUNCTION        shift and go to state 27
    DO              shift and go to state 29

  ! ID              [ reduce using rule 18 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! IF              [ reduce using rule 18 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! WHILE           [ reduce using rule 18 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! FOR             [ reduce using rule 18 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! PRINT           [ reduce using rule 18 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! FUNCTION        [ reduce using rule 18 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! DO              [ reduce using rule 18 (estatutoExp -> estatutoExp estatutoExp .) ]

    estatutoExp                    shift and go to state 34
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    condicion                      shift and go to state 14
    whileLoop                      shift and go to state 15
    doWhile                        shift and go to state 16
    forLoop                        shift and go to state 17
    escritura                      shift and go to state 18
    funcion                        shift and go to state 19
    functionCall                   shift and go to state 20
    do                             shift and go to state 24
    funCall                        shift and go to state 28

state 35

    (15) bloque -> LCURLY declaracion estatutoExp RCURLY .

    $end            reduce using rule 15 (bloque -> LCURLY declaracion estatutoExp RCURLY .)
    WHILE           reduce using rule 15 (bloque -> LCURLY declaracion estatutoExp RCURLY .)
    ELSE            reduce using rule 15 (bloque -> LCURLY declaracion estatutoExp RCURLY .)
    SEMICOLON       reduce using rule 15 (bloque -> LCURLY declaracion estatutoExp RCURLY .)


state 36

    (17) estatutoExp -> estatuto SEMICOLON .

    RCURLY          reduce using rule 17 (estatutoExp -> estatuto SEMICOLON .)
    ID              reduce using rule 17 (estatutoExp -> estatuto SEMICOLON .)
    IF              reduce using rule 17 (estatutoExp -> estatuto SEMICOLON .)
    WHILE           reduce using rule 17 (estatutoExp -> estatuto SEMICOLON .)
    FOR             reduce using rule 17 (estatutoExp -> estatuto SEMICOLON .)
    PRINT           reduce using rule 17 (estatutoExp -> estatuto SEMICOLON .)
    FUNCTION        reduce using rule 17 (estatutoExp -> estatuto SEMICOLON .)
    DO              reduce using rule 17 (estatutoExp -> estatuto SEMICOLON .)
    RETURN          reduce using rule 17 (estatutoExp -> estatuto SEMICOLON .)


state 37

    (28) asignacion -> ID EQUAL . expresion
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

    expresion                      shift and go to state 52
    exp                            shift and go to state 53
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    funCall                        shift and go to state 28
    paren                          shift and go to state 59
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 38

    (51) condicion -> IF LPAREN . expresion endCondition bloque condicionelse
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

    expresion                      shift and go to state 70
    exp                            shift and go to state 53
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    funCall                        shift and go to state 28
    paren                          shift and go to state 59
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 39

    (47) whileLoop -> WHILE startCondition . expresion endCondition bloque
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

    expresion                      shift and go to state 71
    exp                            shift and go to state 53
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    funCall                        shift and go to state 28
    paren                          shift and go to state 59
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 40

    (48) startCondition -> LPAREN .

    LBRACKET        reduce using rule 48 (startCondition -> LPAREN .)
    ID              reduce using rule 48 (startCondition -> LPAREN .)
    LPAREN          reduce using rule 48 (startCondition -> LPAREN .)
    RPAREN          reduce using rule 48 (startCondition -> LPAREN .)
    INT             reduce using rule 48 (startCondition -> LPAREN .)
    FLOAT           reduce using rule 48 (startCondition -> LPAREN .)
    BOOL            reduce using rule 48 (startCondition -> LPAREN .)
    STRING          reduce using rule 48 (startCondition -> LPAREN .)


state 41

    (49) startCondition -> SEMICOLON .

    LBRACKET        reduce using rule 49 (startCondition -> SEMICOLON .)
    ID              reduce using rule 49 (startCondition -> SEMICOLON .)
    LPAREN          reduce using rule 49 (startCondition -> SEMICOLON .)
    RPAREN          reduce using rule 49 (startCondition -> SEMICOLON .)
    INT             reduce using rule 49 (startCondition -> SEMICOLON .)
    FLOAT           reduce using rule 49 (startCondition -> SEMICOLON .)
    BOOL            reduce using rule 49 (startCondition -> SEMICOLON .)
    STRING          reduce using rule 49 (startCondition -> SEMICOLON .)


state 42

    (45) doWhile -> do bloque . WHILE LPAREN expresion RPAREN

    WHILE           shift and go to state 72


state 43

    (50) forLoop -> FOR LPAREN . argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (72) argumentos -> . args
    (73) argumentos -> . epsilon
    (74) args -> . asignacion
    (75) args -> . args COMA args
    (91) epsilon -> .
    (28) asignacion -> . ID EQUAL expresion

    LPAREN          reduce using rule 91 (epsilon -> .)
    SEMICOLON       reduce using rule 91 (epsilon -> .)
    ID              shift and go to state 77

    argumentos                     shift and go to state 73
    asignacion                     shift and go to state 74
    args                           shift and go to state 75
    epsilon                        shift and go to state 76

state 44

    (29) escritura -> PRINT LPAREN . escrito RPAREN
    (30) escrito -> . impr
    (31) escrito -> . impr COMA impr
    (32) impr -> . STRING
    (33) impr -> . expresion
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

    STRING          shift and go to state 80
    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68

    escrito                        shift and go to state 78
    impr                           shift and go to state 79
    expresion                      shift and go to state 81
    exp                            shift and go to state 53
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    funCall                        shift and go to state 28
    paren                          shift and go to state 59
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 45

    (57) funcion -> FUNCTION funcdef . LPAREN declaracion addArgs RPAREN COLON tiposreturn

    LPAREN          shift and go to state 82


state 46

    (59) funcdef -> ID .

    LPAREN          reduce using rule 59 (funcdef -> ID .)


state 47

    (66) functionCall -> funCall paren . funcArgs paren
    (68) funcArgs -> . checkArgs
    (69) funcArgs -> . funcArgs COMA funcArgs
    (70) funcArgs -> . epsilon
    (71) checkArgs -> . expresion
    (91) epsilon -> .
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for RPAREN resolved as shift
    COMA            reduce using rule 91 (epsilon -> .)
    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

  ! LPAREN          [ reduce using rule 91 (epsilon -> .) ]
  ! RPAREN          [ reduce using rule 91 (epsilon -> .) ]

    funCall                        shift and go to state 28
    paren                          shift and go to state 59
    funcArgs                       shift and go to state 83
    checkArgs                      shift and go to state 84
    epsilon                        shift and go to state 85
    expresion                      shift and go to state 86
    exp                            shift and go to state 53
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 48

    (89) paren -> LPAREN .

    LBRACKET        reduce using rule 89 (paren -> LPAREN .)
    ID              reduce using rule 89 (paren -> LPAREN .)
    LPAREN          reduce using rule 89 (paren -> LPAREN .)
    RPAREN          reduce using rule 89 (paren -> LPAREN .)
    INT             reduce using rule 89 (paren -> LPAREN .)
    FLOAT           reduce using rule 89 (paren -> LPAREN .)
    BOOL            reduce using rule 89 (paren -> LPAREN .)
    STRING          reduce using rule 89 (paren -> LPAREN .)
    COMA            reduce using rule 89 (paren -> LPAREN .)
    SEMICOLON       reduce using rule 89 (paren -> LPAREN .)
    TIMES           reduce using rule 89 (paren -> LPAREN .)
    DIVIDE          reduce using rule 89 (paren -> LPAREN .)
    DIFF            reduce using rule 89 (paren -> LPAREN .)
    EXP             reduce using rule 89 (paren -> LPAREN .)
    PLUS            reduce using rule 89 (paren -> LPAREN .)
    MINUS           reduce using rule 89 (paren -> LPAREN .)
    LESSTHAN        reduce using rule 89 (paren -> LPAREN .)
    MORETHAN        reduce using rule 89 (paren -> LPAREN .)
    ISEQUAL         reduce using rule 89 (paren -> LPAREN .)
    NOTEQUAL        reduce using rule 89 (paren -> LPAREN .)
    AND             reduce using rule 89 (paren -> LPAREN .)
    OR              reduce using rule 89 (paren -> LPAREN .)


state 49

    (90) paren -> RPAREN .

    LBRACKET        reduce using rule 90 (paren -> RPAREN .)
    ID              reduce using rule 90 (paren -> RPAREN .)
    LPAREN          reduce using rule 90 (paren -> RPAREN .)
    RPAREN          reduce using rule 90 (paren -> RPAREN .)
    INT             reduce using rule 90 (paren -> RPAREN .)
    FLOAT           reduce using rule 90 (paren -> RPAREN .)
    BOOL            reduce using rule 90 (paren -> RPAREN .)
    STRING          reduce using rule 90 (paren -> RPAREN .)
    COMA            reduce using rule 90 (paren -> RPAREN .)
    SEMICOLON       reduce using rule 90 (paren -> RPAREN .)
    TIMES           reduce using rule 90 (paren -> RPAREN .)
    DIVIDE          reduce using rule 90 (paren -> RPAREN .)
    DIFF            reduce using rule 90 (paren -> RPAREN .)
    EXP             reduce using rule 90 (paren -> RPAREN .)
    PLUS            reduce using rule 90 (paren -> RPAREN .)
    MINUS           reduce using rule 90 (paren -> RPAREN .)
    LESSTHAN        reduce using rule 90 (paren -> RPAREN .)
    MORETHAN        reduce using rule 90 (paren -> RPAREN .)
    ISEQUAL         reduce using rule 90 (paren -> RPAREN .)
    NOTEQUAL        reduce using rule 90 (paren -> RPAREN .)
    AND             reduce using rule 90 (paren -> RPAREN .)
    OR              reduce using rule 90 (paren -> RPAREN .)


state 50

    (6) var -> vardef COLON . tipo SEMICOLON
    (8) tipo -> . INT
    (9) tipo -> . FLOAT
    (10) tipo -> . BOOL
    (11) tipo -> . STRING

    INT             shift and go to state 88
    FLOAT           shift and go to state 89
    BOOL            shift and go to state 90
    STRING          shift and go to state 91

    tipo                           shift and go to state 87

state 51

    (67) funCall -> ID .
    (92) varcte -> ID .

  ! reduce/reduce conflict for LPAREN resolved using rule 67 (funCall -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 67 (funCall -> ID .)
    LPAREN          reduce using rule 67 (funCall -> ID .)
    RPAREN          reduce using rule 67 (funCall -> ID .)
    TIMES           reduce using rule 92 (varcte -> ID .)
    DIVIDE          reduce using rule 92 (varcte -> ID .)
    DIFF            reduce using rule 92 (varcte -> ID .)
    EXP             reduce using rule 92 (varcte -> ID .)
    PLUS            reduce using rule 92 (varcte -> ID .)
    MINUS           reduce using rule 92 (varcte -> ID .)
    LESSTHAN        reduce using rule 92 (varcte -> ID .)
    MORETHAN        reduce using rule 92 (varcte -> ID .)
    ISEQUAL         reduce using rule 92 (varcte -> ID .)
    NOTEQUAL        reduce using rule 92 (varcte -> ID .)
    AND             reduce using rule 92 (varcte -> ID .)
    OR              reduce using rule 92 (varcte -> ID .)
    SEMICOLON       reduce using rule 92 (varcte -> ID .)
    COMA            reduce using rule 92 (varcte -> ID .)

  ! LPAREN          [ reduce using rule 92 (varcte -> ID .) ]
  ! RPAREN          [ reduce using rule 92 (varcte -> ID .) ]


state 52

    (28) asignacion -> ID EQUAL expresion .

    SEMICOLON       reduce using rule 28 (asignacion -> ID EQUAL expresion .)
    COMA            reduce using rule 28 (asignacion -> ID EQUAL expresion .)
    LPAREN          reduce using rule 28 (asignacion -> ID EQUAL expresion .)
    RPAREN          reduce using rule 28 (asignacion -> ID EQUAL expresion .)


state 53

    (34) expresion -> exp .
    (38) condition -> exp . comparacion expresion
    (39) comparacion -> . LESSTHAN
    (40) comparacion -> . MORETHAN
    (41) comparacion -> . ISEQUAL
    (42) comparacion -> . NOTEQUAL
    (43) comparacion -> . AND
    (44) comparacion -> . OR

    SEMICOLON       reduce using rule 34 (expresion -> exp .)
    COMA            reduce using rule 34 (expresion -> exp .)
    LPAREN          reduce using rule 34 (expresion -> exp .)
    RPAREN          reduce using rule 34 (expresion -> exp .)
    LESSTHAN        shift and go to state 93
    MORETHAN        shift and go to state 94
    ISEQUAL         shift and go to state 95
    NOTEQUAL        shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98

    comparacion                    shift and go to state 92

state 54

    (35) expresion -> condition .

    SEMICOLON       reduce using rule 35 (expresion -> condition .)
    COMA            reduce using rule 35 (expresion -> condition .)
    LPAREN          reduce using rule 35 (expresion -> condition .)
    RPAREN          reduce using rule 35 (expresion -> condition .)


state 55

    (36) expresion -> arreglo .

    SEMICOLON       reduce using rule 36 (expresion -> arreglo .)
    COMA            reduce using rule 36 (expresion -> arreglo .)
    LPAREN          reduce using rule 36 (expresion -> arreglo .)
    RPAREN          reduce using rule 36 (expresion -> arreglo .)


state 56

    (37) expresion -> functionCall .
    (88) factor -> functionCall .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 37 (expresion -> functionCall .)
  ! reduce/reduce conflict for COMA resolved using rule 37 (expresion -> functionCall .)
  ! reduce/reduce conflict for LPAREN resolved using rule 37 (expresion -> functionCall .)
  ! reduce/reduce conflict for RPAREN resolved using rule 37 (expresion -> functionCall .)
    SEMICOLON       reduce using rule 37 (expresion -> functionCall .)
    COMA            reduce using rule 37 (expresion -> functionCall .)
    LPAREN          reduce using rule 37 (expresion -> functionCall .)
    RPAREN          reduce using rule 37 (expresion -> functionCall .)
    TIMES           reduce using rule 88 (factor -> functionCall .)
    DIVIDE          reduce using rule 88 (factor -> functionCall .)
    DIFF            reduce using rule 88 (factor -> functionCall .)
    EXP             reduce using rule 88 (factor -> functionCall .)
    PLUS            reduce using rule 88 (factor -> functionCall .)
    MINUS           reduce using rule 88 (factor -> functionCall .)
    LESSTHAN        reduce using rule 88 (factor -> functionCall .)
    MORETHAN        reduce using rule 88 (factor -> functionCall .)
    ISEQUAL         reduce using rule 88 (factor -> functionCall .)
    NOTEQUAL        reduce using rule 88 (factor -> functionCall .)
    AND             reduce using rule 88 (factor -> functionCall .)
    OR              reduce using rule 88 (factor -> functionCall .)

  ! SEMICOLON       [ reduce using rule 88 (factor -> functionCall .) ]
  ! COMA            [ reduce using rule 88 (factor -> functionCall .) ]
  ! LPAREN          [ reduce using rule 88 (factor -> functionCall .) ]
  ! RPAREN          [ reduce using rule 88 (factor -> functionCall .) ]


state 57

    (76) exp -> termino .
    (77) exp -> termino . signo exp
    (78) signo -> . PLUS
    (79) signo -> . MINUS

    LESSTHAN        reduce using rule 76 (exp -> termino .)
    MORETHAN        reduce using rule 76 (exp -> termino .)
    ISEQUAL         reduce using rule 76 (exp -> termino .)
    NOTEQUAL        reduce using rule 76 (exp -> termino .)
    AND             reduce using rule 76 (exp -> termino .)
    OR              reduce using rule 76 (exp -> termino .)
    SEMICOLON       reduce using rule 76 (exp -> termino .)
    COMA            reduce using rule 76 (exp -> termino .)
    LPAREN          reduce using rule 76 (exp -> termino .)
    RPAREN          reduce using rule 76 (exp -> termino .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101

    signo                          shift and go to state 99

state 58

    (14) arreglo -> LBRACKET . lista RBRACKET
    (12) lista -> . ID
    (13) lista -> . ID COMA

    ID              shift and go to state 103

    lista                          shift and go to state 102

state 59

    (86) factor -> paren . expresion paren
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

    paren                          shift and go to state 59
    expresion                      shift and go to state 104
    exp                            shift and go to state 53
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    funCall                        shift and go to state 28
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 60

    (80) termino -> factor .
    (81) termino -> factor . operacion termino
    (82) operacion -> . TIMES
    (83) operacion -> . DIVIDE
    (84) operacion -> . DIFF
    (85) operacion -> . EXP

    PLUS            reduce using rule 80 (termino -> factor .)
    MINUS           reduce using rule 80 (termino -> factor .)
    LESSTHAN        reduce using rule 80 (termino -> factor .)
    MORETHAN        reduce using rule 80 (termino -> factor .)
    ISEQUAL         reduce using rule 80 (termino -> factor .)
    NOTEQUAL        reduce using rule 80 (termino -> factor .)
    AND             reduce using rule 80 (termino -> factor .)
    OR              reduce using rule 80 (termino -> factor .)
    SEMICOLON       reduce using rule 80 (termino -> factor .)
    COMA            reduce using rule 80 (termino -> factor .)
    LPAREN          reduce using rule 80 (termino -> factor .)
    RPAREN          reduce using rule 80 (termino -> factor .)
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    DIFF            shift and go to state 108
    EXP             shift and go to state 109

    operacion                      shift and go to state 105

state 61

    (87) factor -> varcte .

    TIMES           reduce using rule 87 (factor -> varcte .)
    DIVIDE          reduce using rule 87 (factor -> varcte .)
    DIFF            reduce using rule 87 (factor -> varcte .)
    EXP             reduce using rule 87 (factor -> varcte .)
    PLUS            reduce using rule 87 (factor -> varcte .)
    MINUS           reduce using rule 87 (factor -> varcte .)
    LESSTHAN        reduce using rule 87 (factor -> varcte .)
    MORETHAN        reduce using rule 87 (factor -> varcte .)
    ISEQUAL         reduce using rule 87 (factor -> varcte .)
    NOTEQUAL        reduce using rule 87 (factor -> varcte .)
    AND             reduce using rule 87 (factor -> varcte .)
    OR              reduce using rule 87 (factor -> varcte .)
    SEMICOLON       reduce using rule 87 (factor -> varcte .)
    COMA            reduce using rule 87 (factor -> varcte .)
    LPAREN          reduce using rule 87 (factor -> varcte .)
    RPAREN          reduce using rule 87 (factor -> varcte .)


state 62

    (93) varcte -> int .

    TIMES           reduce using rule 93 (varcte -> int .)
    DIVIDE          reduce using rule 93 (varcte -> int .)
    DIFF            reduce using rule 93 (varcte -> int .)
    EXP             reduce using rule 93 (varcte -> int .)
    PLUS            reduce using rule 93 (varcte -> int .)
    MINUS           reduce using rule 93 (varcte -> int .)
    LESSTHAN        reduce using rule 93 (varcte -> int .)
    MORETHAN        reduce using rule 93 (varcte -> int .)
    ISEQUAL         reduce using rule 93 (varcte -> int .)
    NOTEQUAL        reduce using rule 93 (varcte -> int .)
    AND             reduce using rule 93 (varcte -> int .)
    OR              reduce using rule 93 (varcte -> int .)
    SEMICOLON       reduce using rule 93 (varcte -> int .)
    COMA            reduce using rule 93 (varcte -> int .)
    LPAREN          reduce using rule 93 (varcte -> int .)
    RPAREN          reduce using rule 93 (varcte -> int .)


state 63

    (94) varcte -> float .

    TIMES           reduce using rule 94 (varcte -> float .)
    DIVIDE          reduce using rule 94 (varcte -> float .)
    DIFF            reduce using rule 94 (varcte -> float .)
    EXP             reduce using rule 94 (varcte -> float .)
    PLUS            reduce using rule 94 (varcte -> float .)
    MINUS           reduce using rule 94 (varcte -> float .)
    LESSTHAN        reduce using rule 94 (varcte -> float .)
    MORETHAN        reduce using rule 94 (varcte -> float .)
    ISEQUAL         reduce using rule 94 (varcte -> float .)
    NOTEQUAL        reduce using rule 94 (varcte -> float .)
    AND             reduce using rule 94 (varcte -> float .)
    OR              reduce using rule 94 (varcte -> float .)
    SEMICOLON       reduce using rule 94 (varcte -> float .)
    COMA            reduce using rule 94 (varcte -> float .)
    LPAREN          reduce using rule 94 (varcte -> float .)
    RPAREN          reduce using rule 94 (varcte -> float .)


state 64

    (95) varcte -> bool .

    TIMES           reduce using rule 95 (varcte -> bool .)
    DIVIDE          reduce using rule 95 (varcte -> bool .)
    DIFF            reduce using rule 95 (varcte -> bool .)
    EXP             reduce using rule 95 (varcte -> bool .)
    PLUS            reduce using rule 95 (varcte -> bool .)
    MINUS           reduce using rule 95 (varcte -> bool .)
    LESSTHAN        reduce using rule 95 (varcte -> bool .)
    MORETHAN        reduce using rule 95 (varcte -> bool .)
    ISEQUAL         reduce using rule 95 (varcte -> bool .)
    NOTEQUAL        reduce using rule 95 (varcte -> bool .)
    AND             reduce using rule 95 (varcte -> bool .)
    OR              reduce using rule 95 (varcte -> bool .)
    SEMICOLON       reduce using rule 95 (varcte -> bool .)
    COMA            reduce using rule 95 (varcte -> bool .)
    LPAREN          reduce using rule 95 (varcte -> bool .)
    RPAREN          reduce using rule 95 (varcte -> bool .)


state 65

    (96) varcte -> string .

    TIMES           reduce using rule 96 (varcte -> string .)
    DIVIDE          reduce using rule 96 (varcte -> string .)
    DIFF            reduce using rule 96 (varcte -> string .)
    EXP             reduce using rule 96 (varcte -> string .)
    PLUS            reduce using rule 96 (varcte -> string .)
    MINUS           reduce using rule 96 (varcte -> string .)
    LESSTHAN        reduce using rule 96 (varcte -> string .)
    MORETHAN        reduce using rule 96 (varcte -> string .)
    ISEQUAL         reduce using rule 96 (varcte -> string .)
    NOTEQUAL        reduce using rule 96 (varcte -> string .)
    AND             reduce using rule 96 (varcte -> string .)
    OR              reduce using rule 96 (varcte -> string .)
    SEMICOLON       reduce using rule 96 (varcte -> string .)
    COMA            reduce using rule 96 (varcte -> string .)
    LPAREN          reduce using rule 96 (varcte -> string .)
    RPAREN          reduce using rule 96 (varcte -> string .)


state 66

    (97) int -> INT .

    TIMES           reduce using rule 97 (int -> INT .)
    DIVIDE          reduce using rule 97 (int -> INT .)
    DIFF            reduce using rule 97 (int -> INT .)
    EXP             reduce using rule 97 (int -> INT .)
    PLUS            reduce using rule 97 (int -> INT .)
    MINUS           reduce using rule 97 (int -> INT .)
    LESSTHAN        reduce using rule 97 (int -> INT .)
    MORETHAN        reduce using rule 97 (int -> INT .)
    ISEQUAL         reduce using rule 97 (int -> INT .)
    NOTEQUAL        reduce using rule 97 (int -> INT .)
    AND             reduce using rule 97 (int -> INT .)
    OR              reduce using rule 97 (int -> INT .)
    SEMICOLON       reduce using rule 97 (int -> INT .)
    COMA            reduce using rule 97 (int -> INT .)
    LPAREN          reduce using rule 97 (int -> INT .)
    RPAREN          reduce using rule 97 (int -> INT .)


state 67

    (98) float -> FLOAT .

    TIMES           reduce using rule 98 (float -> FLOAT .)
    DIVIDE          reduce using rule 98 (float -> FLOAT .)
    DIFF            reduce using rule 98 (float -> FLOAT .)
    EXP             reduce using rule 98 (float -> FLOAT .)
    PLUS            reduce using rule 98 (float -> FLOAT .)
    MINUS           reduce using rule 98 (float -> FLOAT .)
    LESSTHAN        reduce using rule 98 (float -> FLOAT .)
    MORETHAN        reduce using rule 98 (float -> FLOAT .)
    ISEQUAL         reduce using rule 98 (float -> FLOAT .)
    NOTEQUAL        reduce using rule 98 (float -> FLOAT .)
    AND             reduce using rule 98 (float -> FLOAT .)
    OR              reduce using rule 98 (float -> FLOAT .)
    SEMICOLON       reduce using rule 98 (float -> FLOAT .)
    COMA            reduce using rule 98 (float -> FLOAT .)
    LPAREN          reduce using rule 98 (float -> FLOAT .)
    RPAREN          reduce using rule 98 (float -> FLOAT .)


state 68

    (99) bool -> BOOL .

    TIMES           reduce using rule 99 (bool -> BOOL .)
    DIVIDE          reduce using rule 99 (bool -> BOOL .)
    DIFF            reduce using rule 99 (bool -> BOOL .)
    EXP             reduce using rule 99 (bool -> BOOL .)
    PLUS            reduce using rule 99 (bool -> BOOL .)
    MINUS           reduce using rule 99 (bool -> BOOL .)
    LESSTHAN        reduce using rule 99 (bool -> BOOL .)
    MORETHAN        reduce using rule 99 (bool -> BOOL .)
    ISEQUAL         reduce using rule 99 (bool -> BOOL .)
    NOTEQUAL        reduce using rule 99 (bool -> BOOL .)
    AND             reduce using rule 99 (bool -> BOOL .)
    OR              reduce using rule 99 (bool -> BOOL .)
    SEMICOLON       reduce using rule 99 (bool -> BOOL .)
    COMA            reduce using rule 99 (bool -> BOOL .)
    LPAREN          reduce using rule 99 (bool -> BOOL .)
    RPAREN          reduce using rule 99 (bool -> BOOL .)


state 69

    (100) string -> STRING .

    TIMES           reduce using rule 100 (string -> STRING .)
    DIVIDE          reduce using rule 100 (string -> STRING .)
    DIFF            reduce using rule 100 (string -> STRING .)
    EXP             reduce using rule 100 (string -> STRING .)
    PLUS            reduce using rule 100 (string -> STRING .)
    MINUS           reduce using rule 100 (string -> STRING .)
    LESSTHAN        reduce using rule 100 (string -> STRING .)
    MORETHAN        reduce using rule 100 (string -> STRING .)
    ISEQUAL         reduce using rule 100 (string -> STRING .)
    NOTEQUAL        reduce using rule 100 (string -> STRING .)
    AND             reduce using rule 100 (string -> STRING .)
    OR              reduce using rule 100 (string -> STRING .)
    SEMICOLON       reduce using rule 100 (string -> STRING .)
    COMA            reduce using rule 100 (string -> STRING .)
    LPAREN          reduce using rule 100 (string -> STRING .)
    RPAREN          reduce using rule 100 (string -> STRING .)


state 70

    (51) condicion -> IF LPAREN expresion . endCondition bloque condicionelse
    (52) endCondition -> . RPAREN
    (53) endCondition -> . SEMICOLON

    RPAREN          shift and go to state 111
    SEMICOLON       shift and go to state 112

    endCondition                   shift and go to state 110

state 71

    (47) whileLoop -> WHILE startCondition expresion . endCondition bloque
    (52) endCondition -> . RPAREN
    (53) endCondition -> . SEMICOLON

    RPAREN          shift and go to state 111
    SEMICOLON       shift and go to state 112

    endCondition                   shift and go to state 113

state 72

    (45) doWhile -> do bloque WHILE . LPAREN expresion RPAREN

    LPAREN          shift and go to state 114


state 73

    (50) forLoop -> FOR LPAREN argumentos . startCondition expresion endCondition asignacion RPAREN bloque
    (48) startCondition -> . LPAREN
    (49) startCondition -> . SEMICOLON

    LPAREN          shift and go to state 40
    SEMICOLON       shift and go to state 41

    startCondition                 shift and go to state 115

state 74

    (74) args -> asignacion .

    COMA            reduce using rule 74 (args -> asignacion .)
    LPAREN          reduce using rule 74 (args -> asignacion .)
    SEMICOLON       reduce using rule 74 (args -> asignacion .)


state 75

    (72) argumentos -> args .
    (75) args -> args . COMA args

    LPAREN          reduce using rule 72 (argumentos -> args .)
    SEMICOLON       reduce using rule 72 (argumentos -> args .)
    COMA            shift and go to state 116


state 76

    (73) argumentos -> epsilon .

    LPAREN          reduce using rule 73 (argumentos -> epsilon .)
    SEMICOLON       reduce using rule 73 (argumentos -> epsilon .)


state 77

    (28) asignacion -> ID . EQUAL expresion

    EQUAL           shift and go to state 37


state 78

    (29) escritura -> PRINT LPAREN escrito . RPAREN

    RPAREN          shift and go to state 117


state 79

    (30) escrito -> impr .
    (31) escrito -> impr . COMA impr

    RPAREN          reduce using rule 30 (escrito -> impr .)
    COMA            shift and go to state 118


state 80

    (32) impr -> STRING .
    (100) string -> STRING .

  ! reduce/reduce conflict for COMA resolved using rule 32 (impr -> STRING .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (impr -> STRING .)
    COMA            reduce using rule 32 (impr -> STRING .)
    RPAREN          reduce using rule 32 (impr -> STRING .)
    TIMES           reduce using rule 100 (string -> STRING .)
    DIVIDE          reduce using rule 100 (string -> STRING .)
    DIFF            reduce using rule 100 (string -> STRING .)
    EXP             reduce using rule 100 (string -> STRING .)
    PLUS            reduce using rule 100 (string -> STRING .)
    MINUS           reduce using rule 100 (string -> STRING .)
    LESSTHAN        reduce using rule 100 (string -> STRING .)
    MORETHAN        reduce using rule 100 (string -> STRING .)
    ISEQUAL         reduce using rule 100 (string -> STRING .)
    NOTEQUAL        reduce using rule 100 (string -> STRING .)
    AND             reduce using rule 100 (string -> STRING .)
    OR              reduce using rule 100 (string -> STRING .)

  ! COMA            [ reduce using rule 100 (string -> STRING .) ]
  ! RPAREN          [ reduce using rule 100 (string -> STRING .) ]


state 81

    (33) impr -> expresion .

    COMA            reduce using rule 33 (impr -> expresion .)
    RPAREN          reduce using rule 33 (impr -> expresion .)


state 82

    (57) funcion -> FUNCTION funcdef LPAREN . declaracion addArgs RPAREN COLON tiposreturn
    (2) declaracion -> . vars
    (3) declaracion -> . epsilon
    (4) vars -> . VAR var
    (5) vars -> . vars vars
    (91) epsilon -> .

    VAR             shift and go to state 10
    RPAREN          reduce using rule 91 (epsilon -> .)

    declaracion                    shift and go to state 119
    vars                           shift and go to state 8
    epsilon                        shift and go to state 9

state 83

    (66) functionCall -> funCall paren funcArgs . paren
    (69) funcArgs -> funcArgs . COMA funcArgs
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN

    COMA            shift and go to state 121
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49

    paren                          shift and go to state 120

state 84

    (68) funcArgs -> checkArgs .

    COMA            reduce using rule 68 (funcArgs -> checkArgs .)
    LPAREN          reduce using rule 68 (funcArgs -> checkArgs .)
    RPAREN          reduce using rule 68 (funcArgs -> checkArgs .)


state 85

    (70) funcArgs -> epsilon .

    COMA            reduce using rule 70 (funcArgs -> epsilon .)
    LPAREN          reduce using rule 70 (funcArgs -> epsilon .)
    RPAREN          reduce using rule 70 (funcArgs -> epsilon .)


state 86

    (71) checkArgs -> expresion .

    COMA            reduce using rule 71 (checkArgs -> expresion .)
    LPAREN          reduce using rule 71 (checkArgs -> expresion .)
    RPAREN          reduce using rule 71 (checkArgs -> expresion .)


state 87

    (6) var -> vardef COLON tipo . SEMICOLON

    SEMICOLON       shift and go to state 122


state 88

    (8) tipo -> INT .

    SEMICOLON       reduce using rule 8 (tipo -> INT .)


state 89

    (9) tipo -> FLOAT .

    SEMICOLON       reduce using rule 9 (tipo -> FLOAT .)


state 90

    (10) tipo -> BOOL .

    SEMICOLON       reduce using rule 10 (tipo -> BOOL .)


state 91

    (11) tipo -> STRING .

    SEMICOLON       reduce using rule 11 (tipo -> STRING .)


state 92

    (38) condition -> exp comparacion . expresion
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

    exp                            shift and go to state 53
    expresion                      shift and go to state 123
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    funCall                        shift and go to state 28
    paren                          shift and go to state 59
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 93

    (39) comparacion -> LESSTHAN .

    LBRACKET        reduce using rule 39 (comparacion -> LESSTHAN .)
    ID              reduce using rule 39 (comparacion -> LESSTHAN .)
    LPAREN          reduce using rule 39 (comparacion -> LESSTHAN .)
    RPAREN          reduce using rule 39 (comparacion -> LESSTHAN .)
    INT             reduce using rule 39 (comparacion -> LESSTHAN .)
    FLOAT           reduce using rule 39 (comparacion -> LESSTHAN .)
    BOOL            reduce using rule 39 (comparacion -> LESSTHAN .)
    STRING          reduce using rule 39 (comparacion -> LESSTHAN .)


state 94

    (40) comparacion -> MORETHAN .

    LBRACKET        reduce using rule 40 (comparacion -> MORETHAN .)
    ID              reduce using rule 40 (comparacion -> MORETHAN .)
    LPAREN          reduce using rule 40 (comparacion -> MORETHAN .)
    RPAREN          reduce using rule 40 (comparacion -> MORETHAN .)
    INT             reduce using rule 40 (comparacion -> MORETHAN .)
    FLOAT           reduce using rule 40 (comparacion -> MORETHAN .)
    BOOL            reduce using rule 40 (comparacion -> MORETHAN .)
    STRING          reduce using rule 40 (comparacion -> MORETHAN .)


state 95

    (41) comparacion -> ISEQUAL .

    LBRACKET        reduce using rule 41 (comparacion -> ISEQUAL .)
    ID              reduce using rule 41 (comparacion -> ISEQUAL .)
    LPAREN          reduce using rule 41 (comparacion -> ISEQUAL .)
    RPAREN          reduce using rule 41 (comparacion -> ISEQUAL .)
    INT             reduce using rule 41 (comparacion -> ISEQUAL .)
    FLOAT           reduce using rule 41 (comparacion -> ISEQUAL .)
    BOOL            reduce using rule 41 (comparacion -> ISEQUAL .)
    STRING          reduce using rule 41 (comparacion -> ISEQUAL .)


state 96

    (42) comparacion -> NOTEQUAL .

    LBRACKET        reduce using rule 42 (comparacion -> NOTEQUAL .)
    ID              reduce using rule 42 (comparacion -> NOTEQUAL .)
    LPAREN          reduce using rule 42 (comparacion -> NOTEQUAL .)
    RPAREN          reduce using rule 42 (comparacion -> NOTEQUAL .)
    INT             reduce using rule 42 (comparacion -> NOTEQUAL .)
    FLOAT           reduce using rule 42 (comparacion -> NOTEQUAL .)
    BOOL            reduce using rule 42 (comparacion -> NOTEQUAL .)
    STRING          reduce using rule 42 (comparacion -> NOTEQUAL .)


state 97

    (43) comparacion -> AND .

    LBRACKET        reduce using rule 43 (comparacion -> AND .)
    ID              reduce using rule 43 (comparacion -> AND .)
    LPAREN          reduce using rule 43 (comparacion -> AND .)
    RPAREN          reduce using rule 43 (comparacion -> AND .)
    INT             reduce using rule 43 (comparacion -> AND .)
    FLOAT           reduce using rule 43 (comparacion -> AND .)
    BOOL            reduce using rule 43 (comparacion -> AND .)
    STRING          reduce using rule 43 (comparacion -> AND .)


state 98

    (44) comparacion -> OR .

    LBRACKET        reduce using rule 44 (comparacion -> OR .)
    ID              reduce using rule 44 (comparacion -> OR .)
    LPAREN          reduce using rule 44 (comparacion -> OR .)
    RPAREN          reduce using rule 44 (comparacion -> OR .)
    INT             reduce using rule 44 (comparacion -> OR .)
    FLOAT           reduce using rule 44 (comparacion -> OR .)
    BOOL            reduce using rule 44 (comparacion -> OR .)
    STRING          reduce using rule 44 (comparacion -> OR .)


state 99

    (77) exp -> termino signo . exp
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (66) functionCall -> . funCall paren funcArgs paren
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING
    (67) funCall -> . ID

    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    ID              shift and go to state 126
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

    termino                        shift and go to state 57
    exp                            shift and go to state 124
    factor                         shift and go to state 60
    paren                          shift and go to state 59
    varcte                         shift and go to state 61
    functionCall                   shift and go to state 125
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65
    funCall                        shift and go to state 28

state 100

    (78) signo -> PLUS .

    LPAREN          reduce using rule 78 (signo -> PLUS .)
    RPAREN          reduce using rule 78 (signo -> PLUS .)
    ID              reduce using rule 78 (signo -> PLUS .)
    INT             reduce using rule 78 (signo -> PLUS .)
    FLOAT           reduce using rule 78 (signo -> PLUS .)
    BOOL            reduce using rule 78 (signo -> PLUS .)
    STRING          reduce using rule 78 (signo -> PLUS .)


state 101

    (79) signo -> MINUS .

    LPAREN          reduce using rule 79 (signo -> MINUS .)
    RPAREN          reduce using rule 79 (signo -> MINUS .)
    ID              reduce using rule 79 (signo -> MINUS .)
    INT             reduce using rule 79 (signo -> MINUS .)
    FLOAT           reduce using rule 79 (signo -> MINUS .)
    BOOL            reduce using rule 79 (signo -> MINUS .)
    STRING          reduce using rule 79 (signo -> MINUS .)


state 102

    (14) arreglo -> LBRACKET lista . RBRACKET

    RBRACKET        shift and go to state 127


state 103

    (12) lista -> ID .
    (13) lista -> ID . COMA

    RBRACKET        reduce using rule 12 (lista -> ID .)
    COMA            shift and go to state 128


state 104

    (86) factor -> paren expresion . paren
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN

    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49

    paren                          shift and go to state 129

state 105

    (81) termino -> factor operacion . termino
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (66) functionCall -> . funCall paren funcArgs paren
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING
    (67) funCall -> . ID

    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    ID              shift and go to state 126
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

    factor                         shift and go to state 60
    termino                        shift and go to state 130
    paren                          shift and go to state 59
    varcte                         shift and go to state 61
    functionCall                   shift and go to state 125
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65
    funCall                        shift and go to state 28

state 106

    (82) operacion -> TIMES .

    LPAREN          reduce using rule 82 (operacion -> TIMES .)
    RPAREN          reduce using rule 82 (operacion -> TIMES .)
    ID              reduce using rule 82 (operacion -> TIMES .)
    INT             reduce using rule 82 (operacion -> TIMES .)
    FLOAT           reduce using rule 82 (operacion -> TIMES .)
    BOOL            reduce using rule 82 (operacion -> TIMES .)
    STRING          reduce using rule 82 (operacion -> TIMES .)


state 107

    (83) operacion -> DIVIDE .

    LPAREN          reduce using rule 83 (operacion -> DIVIDE .)
    RPAREN          reduce using rule 83 (operacion -> DIVIDE .)
    ID              reduce using rule 83 (operacion -> DIVIDE .)
    INT             reduce using rule 83 (operacion -> DIVIDE .)
    FLOAT           reduce using rule 83 (operacion -> DIVIDE .)
    BOOL            reduce using rule 83 (operacion -> DIVIDE .)
    STRING          reduce using rule 83 (operacion -> DIVIDE .)


state 108

    (84) operacion -> DIFF .

    LPAREN          reduce using rule 84 (operacion -> DIFF .)
    RPAREN          reduce using rule 84 (operacion -> DIFF .)
    ID              reduce using rule 84 (operacion -> DIFF .)
    INT             reduce using rule 84 (operacion -> DIFF .)
    FLOAT           reduce using rule 84 (operacion -> DIFF .)
    BOOL            reduce using rule 84 (operacion -> DIFF .)
    STRING          reduce using rule 84 (operacion -> DIFF .)


state 109

    (85) operacion -> EXP .

    LPAREN          reduce using rule 85 (operacion -> EXP .)
    RPAREN          reduce using rule 85 (operacion -> EXP .)
    ID              reduce using rule 85 (operacion -> EXP .)
    INT             reduce using rule 85 (operacion -> EXP .)
    FLOAT           reduce using rule 85 (operacion -> EXP .)
    BOOL            reduce using rule 85 (operacion -> EXP .)
    STRING          reduce using rule 85 (operacion -> EXP .)


state 110

    (51) condicion -> IF LPAREN expresion endCondition . bloque condicionelse
    (15) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 131

state 111

    (52) endCondition -> RPAREN .

    LCURLY          reduce using rule 52 (endCondition -> RPAREN .)
    ID              reduce using rule 52 (endCondition -> RPAREN .)


state 112

    (53) endCondition -> SEMICOLON .

    LCURLY          reduce using rule 53 (endCondition -> SEMICOLON .)
    ID              reduce using rule 53 (endCondition -> SEMICOLON .)


state 113

    (47) whileLoop -> WHILE startCondition expresion endCondition . bloque
    (15) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 132

state 114

    (45) doWhile -> do bloque WHILE LPAREN . expresion RPAREN
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

    expresion                      shift and go to state 133
    exp                            shift and go to state 53
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    funCall                        shift and go to state 28
    paren                          shift and go to state 59
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 115

    (50) forLoop -> FOR LPAREN argumentos startCondition . expresion endCondition asignacion RPAREN bloque
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

    expresion                      shift and go to state 134
    exp                            shift and go to state 53
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    funCall                        shift and go to state 28
    paren                          shift and go to state 59
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 116

    (75) args -> args COMA . args
    (74) args -> . asignacion
    (75) args -> . args COMA args
    (28) asignacion -> . ID EQUAL expresion

    ID              shift and go to state 77

    args                           shift and go to state 135
    asignacion                     shift and go to state 74

state 117

    (29) escritura -> PRINT LPAREN escrito RPAREN .

    SEMICOLON       reduce using rule 29 (escritura -> PRINT LPAREN escrito RPAREN .)


state 118

    (31) escrito -> impr COMA . impr
    (32) impr -> . STRING
    (33) impr -> . expresion
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

    STRING          shift and go to state 80
    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68

    impr                           shift and go to state 136
    expresion                      shift and go to state 81
    exp                            shift and go to state 53
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    funCall                        shift and go to state 28
    paren                          shift and go to state 59
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 119

    (57) funcion -> FUNCTION funcdef LPAREN declaracion . addArgs RPAREN COLON tiposreturn
    (58) addArgs -> . epsilon
    (91) epsilon -> .

    RPAREN          reduce using rule 91 (epsilon -> .)

    addArgs                        shift and go to state 137
    epsilon                        shift and go to state 138

state 120

    (66) functionCall -> funCall paren funcArgs paren .

    SEMICOLON       reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    COMA            reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    LPAREN          reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    RPAREN          reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    TIMES           reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    DIVIDE          reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    DIFF            reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    EXP             reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    PLUS            reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    MINUS           reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    LESSTHAN        reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    MORETHAN        reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    ISEQUAL         reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    NOTEQUAL        reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    AND             reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)
    OR              reduce using rule 66 (functionCall -> funCall paren funcArgs paren .)


state 121

    (69) funcArgs -> funcArgs COMA . funcArgs
    (68) funcArgs -> . checkArgs
    (69) funcArgs -> . funcArgs COMA funcArgs
    (70) funcArgs -> . epsilon
    (71) checkArgs -> . expresion
    (91) epsilon -> .
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for RPAREN resolved as shift
    COMA            reduce using rule 91 (epsilon -> .)
    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

  ! LPAREN          [ reduce using rule 91 (epsilon -> .) ]
  ! RPAREN          [ reduce using rule 91 (epsilon -> .) ]

    funcArgs                       shift and go to state 139
    checkArgs                      shift and go to state 84
    epsilon                        shift and go to state 85
    expresion                      shift and go to state 86
    exp                            shift and go to state 53
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    funCall                        shift and go to state 28
    paren                          shift and go to state 59
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 122

    (6) var -> vardef COLON tipo SEMICOLON .

    VAR             reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    ID              reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    IF              reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    WHILE           reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    FOR             reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    PRINT           reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    FUNCTION        reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    DO              reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    RPAREN          reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)


state 123

    (38) condition -> exp comparacion expresion .

    SEMICOLON       reduce using rule 38 (condition -> exp comparacion expresion .)
    COMA            reduce using rule 38 (condition -> exp comparacion expresion .)
    LPAREN          reduce using rule 38 (condition -> exp comparacion expresion .)
    RPAREN          reduce using rule 38 (condition -> exp comparacion expresion .)


state 124

    (77) exp -> termino signo exp .

    LESSTHAN        reduce using rule 77 (exp -> termino signo exp .)
    MORETHAN        reduce using rule 77 (exp -> termino signo exp .)
    ISEQUAL         reduce using rule 77 (exp -> termino signo exp .)
    NOTEQUAL        reduce using rule 77 (exp -> termino signo exp .)
    AND             reduce using rule 77 (exp -> termino signo exp .)
    OR              reduce using rule 77 (exp -> termino signo exp .)
    SEMICOLON       reduce using rule 77 (exp -> termino signo exp .)
    COMA            reduce using rule 77 (exp -> termino signo exp .)
    LPAREN          reduce using rule 77 (exp -> termino signo exp .)
    RPAREN          reduce using rule 77 (exp -> termino signo exp .)


state 125

    (88) factor -> functionCall .

    TIMES           reduce using rule 88 (factor -> functionCall .)
    DIVIDE          reduce using rule 88 (factor -> functionCall .)
    DIFF            reduce using rule 88 (factor -> functionCall .)
    EXP             reduce using rule 88 (factor -> functionCall .)
    PLUS            reduce using rule 88 (factor -> functionCall .)
    MINUS           reduce using rule 88 (factor -> functionCall .)
    LESSTHAN        reduce using rule 88 (factor -> functionCall .)
    MORETHAN        reduce using rule 88 (factor -> functionCall .)
    ISEQUAL         reduce using rule 88 (factor -> functionCall .)
    NOTEQUAL        reduce using rule 88 (factor -> functionCall .)
    AND             reduce using rule 88 (factor -> functionCall .)
    OR              reduce using rule 88 (factor -> functionCall .)
    SEMICOLON       reduce using rule 88 (factor -> functionCall .)
    COMA            reduce using rule 88 (factor -> functionCall .)
    LPAREN          reduce using rule 88 (factor -> functionCall .)
    RPAREN          reduce using rule 88 (factor -> functionCall .)


state 126

    (92) varcte -> ID .
    (67) funCall -> ID .

  ! reduce/reduce conflict for LPAREN resolved using rule 67 (funCall -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 67 (funCall -> ID .)
    TIMES           reduce using rule 92 (varcte -> ID .)
    DIVIDE          reduce using rule 92 (varcte -> ID .)
    DIFF            reduce using rule 92 (varcte -> ID .)
    EXP             reduce using rule 92 (varcte -> ID .)
    PLUS            reduce using rule 92 (varcte -> ID .)
    MINUS           reduce using rule 92 (varcte -> ID .)
    LESSTHAN        reduce using rule 92 (varcte -> ID .)
    MORETHAN        reduce using rule 92 (varcte -> ID .)
    ISEQUAL         reduce using rule 92 (varcte -> ID .)
    NOTEQUAL        reduce using rule 92 (varcte -> ID .)
    AND             reduce using rule 92 (varcte -> ID .)
    OR              reduce using rule 92 (varcte -> ID .)
    SEMICOLON       reduce using rule 92 (varcte -> ID .)
    COMA            reduce using rule 92 (varcte -> ID .)
    LPAREN          reduce using rule 67 (funCall -> ID .)
    RPAREN          reduce using rule 67 (funCall -> ID .)

  ! LPAREN          [ reduce using rule 92 (varcte -> ID .) ]
  ! RPAREN          [ reduce using rule 92 (varcte -> ID .) ]


state 127

    (14) arreglo -> LBRACKET lista RBRACKET .

    SEMICOLON       reduce using rule 14 (arreglo -> LBRACKET lista RBRACKET .)
    COMA            reduce using rule 14 (arreglo -> LBRACKET lista RBRACKET .)
    LPAREN          reduce using rule 14 (arreglo -> LBRACKET lista RBRACKET .)
    RPAREN          reduce using rule 14 (arreglo -> LBRACKET lista RBRACKET .)


state 128

    (13) lista -> ID COMA .

    RBRACKET        reduce using rule 13 (lista -> ID COMA .)


state 129

    (86) factor -> paren expresion paren .

    TIMES           reduce using rule 86 (factor -> paren expresion paren .)
    DIVIDE          reduce using rule 86 (factor -> paren expresion paren .)
    DIFF            reduce using rule 86 (factor -> paren expresion paren .)
    EXP             reduce using rule 86 (factor -> paren expresion paren .)
    PLUS            reduce using rule 86 (factor -> paren expresion paren .)
    MINUS           reduce using rule 86 (factor -> paren expresion paren .)
    LESSTHAN        reduce using rule 86 (factor -> paren expresion paren .)
    MORETHAN        reduce using rule 86 (factor -> paren expresion paren .)
    ISEQUAL         reduce using rule 86 (factor -> paren expresion paren .)
    NOTEQUAL        reduce using rule 86 (factor -> paren expresion paren .)
    AND             reduce using rule 86 (factor -> paren expresion paren .)
    OR              reduce using rule 86 (factor -> paren expresion paren .)
    SEMICOLON       reduce using rule 86 (factor -> paren expresion paren .)
    COMA            reduce using rule 86 (factor -> paren expresion paren .)
    LPAREN          reduce using rule 86 (factor -> paren expresion paren .)
    RPAREN          reduce using rule 86 (factor -> paren expresion paren .)


state 130

    (81) termino -> factor operacion termino .

    PLUS            reduce using rule 81 (termino -> factor operacion termino .)
    MINUS           reduce using rule 81 (termino -> factor operacion termino .)
    LESSTHAN        reduce using rule 81 (termino -> factor operacion termino .)
    MORETHAN        reduce using rule 81 (termino -> factor operacion termino .)
    ISEQUAL         reduce using rule 81 (termino -> factor operacion termino .)
    NOTEQUAL        reduce using rule 81 (termino -> factor operacion termino .)
    AND             reduce using rule 81 (termino -> factor operacion termino .)
    OR              reduce using rule 81 (termino -> factor operacion termino .)
    SEMICOLON       reduce using rule 81 (termino -> factor operacion termino .)
    COMA            reduce using rule 81 (termino -> factor operacion termino .)
    LPAREN          reduce using rule 81 (termino -> factor operacion termino .)
    RPAREN          reduce using rule 81 (termino -> factor operacion termino .)


state 131

    (51) condicion -> IF LPAREN expresion endCondition bloque . condicionelse
    (54) condicionelse -> . else bloque
    (55) condicionelse -> . epsilon
    (56) else -> . ELSE
    (91) epsilon -> .

    ELSE            shift and go to state 143
    SEMICOLON       reduce using rule 91 (epsilon -> .)

    condicionelse                  shift and go to state 140
    else                           shift and go to state 141
    epsilon                        shift and go to state 142

state 132

    (47) whileLoop -> WHILE startCondition expresion endCondition bloque .

    SEMICOLON       reduce using rule 47 (whileLoop -> WHILE startCondition expresion endCondition bloque .)


state 133

    (45) doWhile -> do bloque WHILE LPAREN expresion . RPAREN

    RPAREN          shift and go to state 144


state 134

    (50) forLoop -> FOR LPAREN argumentos startCondition expresion . endCondition asignacion RPAREN bloque
    (52) endCondition -> . RPAREN
    (53) endCondition -> . SEMICOLON

    RPAREN          shift and go to state 111
    SEMICOLON       shift and go to state 112

    endCondition                   shift and go to state 145

state 135

    (75) args -> args COMA args .
    (75) args -> args . COMA args

  ! shift/reduce conflict for COMA resolved as shift
    LPAREN          reduce using rule 75 (args -> args COMA args .)
    SEMICOLON       reduce using rule 75 (args -> args COMA args .)
    COMA            shift and go to state 116

  ! COMA            [ reduce using rule 75 (args -> args COMA args .) ]


state 136

    (31) escrito -> impr COMA impr .

    RPAREN          reduce using rule 31 (escrito -> impr COMA impr .)


state 137

    (57) funcion -> FUNCTION funcdef LPAREN declaracion addArgs . RPAREN COLON tiposreturn

    RPAREN          shift and go to state 146


state 138

    (58) addArgs -> epsilon .

    RPAREN          reduce using rule 58 (addArgs -> epsilon .)


state 139

    (69) funcArgs -> funcArgs COMA funcArgs .
    (69) funcArgs -> funcArgs . COMA funcArgs

  ! shift/reduce conflict for COMA resolved as shift
    LPAREN          reduce using rule 69 (funcArgs -> funcArgs COMA funcArgs .)
    RPAREN          reduce using rule 69 (funcArgs -> funcArgs COMA funcArgs .)
    COMA            shift and go to state 121

  ! COMA            [ reduce using rule 69 (funcArgs -> funcArgs COMA funcArgs .) ]


state 140

    (51) condicion -> IF LPAREN expresion endCondition bloque condicionelse .

    SEMICOLON       reduce using rule 51 (condicion -> IF LPAREN expresion endCondition bloque condicionelse .)


state 141

    (54) condicionelse -> else . bloque
    (15) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 147

state 142

    (55) condicionelse -> epsilon .

    SEMICOLON       reduce using rule 55 (condicionelse -> epsilon .)


state 143

    (56) else -> ELSE .

    LCURLY          reduce using rule 56 (else -> ELSE .)


state 144

    (45) doWhile -> do bloque WHILE LPAREN expresion RPAREN .

    SEMICOLON       reduce using rule 45 (doWhile -> do bloque WHILE LPAREN expresion RPAREN .)


state 145

    (50) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition . asignacion RPAREN bloque
    (28) asignacion -> . ID EQUAL expresion

    ID              shift and go to state 77

    asignacion                     shift and go to state 148

state 146

    (57) funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN . COLON tiposreturn

    COLON           shift and go to state 149


state 147

    (54) condicionelse -> else bloque .

    SEMICOLON       reduce using rule 54 (condicionelse -> else bloque .)


state 148

    (50) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion . RPAREN bloque

    RPAREN          shift and go to state 150


state 149

    (57) funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON . tiposreturn
    (60) tiposreturn -> . tiposFuncion bloqueReturn
    (61) tiposreturn -> . VOID bloque
    (62) tiposFuncion -> . INT
    (63) tiposFuncion -> . FLOAT
    (64) tiposFuncion -> . BOOL
    (65) tiposFuncion -> . STRING

    VOID            shift and go to state 153
    INT             shift and go to state 154
    FLOAT           shift and go to state 155
    BOOL            shift and go to state 156
    STRING          shift and go to state 157

    tiposreturn                    shift and go to state 151
    tiposFuncion                   shift and go to state 152

state 150

    (50) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN . bloque
    (15) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 158

state 151

    (57) funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn .

    SEMICOLON       reduce using rule 57 (funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn .)


state 152

    (60) tiposreturn -> tiposFuncion . bloqueReturn
    (16) bloqueReturn -> . LCURLY declaracion estatutoExp returnexp RCURLY

    LCURLY          shift and go to state 160

    bloqueReturn                   shift and go to state 159

state 153

    (61) tiposreturn -> VOID . bloque
    (15) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 161

state 154

    (62) tiposFuncion -> INT .

    LCURLY          reduce using rule 62 (tiposFuncion -> INT .)


state 155

    (63) tiposFuncion -> FLOAT .

    LCURLY          reduce using rule 63 (tiposFuncion -> FLOAT .)


state 156

    (64) tiposFuncion -> BOOL .

    LCURLY          reduce using rule 64 (tiposFuncion -> BOOL .)


state 157

    (65) tiposFuncion -> STRING .

    LCURLY          reduce using rule 65 (tiposFuncion -> STRING .)


state 158

    (50) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque .

    SEMICOLON       reduce using rule 50 (forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque .)


state 159

    (60) tiposreturn -> tiposFuncion bloqueReturn .

    SEMICOLON       reduce using rule 60 (tiposreturn -> tiposFuncion bloqueReturn .)


state 160

    (16) bloqueReturn -> LCURLY . declaracion estatutoExp returnexp RCURLY
    (2) declaracion -> . vars
    (3) declaracion -> . epsilon
    (4) vars -> . VAR var
    (5) vars -> . vars vars
    (91) epsilon -> .

    VAR             shift and go to state 10
    ID              reduce using rule 91 (epsilon -> .)
    IF              reduce using rule 91 (epsilon -> .)
    WHILE           reduce using rule 91 (epsilon -> .)
    FOR             reduce using rule 91 (epsilon -> .)
    PRINT           reduce using rule 91 (epsilon -> .)
    FUNCTION        reduce using rule 91 (epsilon -> .)
    DO              reduce using rule 91 (epsilon -> .)

    declaracion                    shift and go to state 162
    vars                           shift and go to state 8
    epsilon                        shift and go to state 9

state 161

    (61) tiposreturn -> VOID bloque .

    SEMICOLON       reduce using rule 61 (tiposreturn -> VOID bloque .)


state 162

    (16) bloqueReturn -> LCURLY declaracion . estatutoExp returnexp RCURLY
    (17) estatutoExp -> . estatuto SEMICOLON
    (18) estatutoExp -> . estatutoExp estatutoExp
    (19) estatuto -> . asignacion
    (20) estatuto -> . condicion
    (21) estatuto -> . whileLoop
    (22) estatuto -> . doWhile
    (23) estatuto -> . forLoop
    (24) estatuto -> . escritura
    (25) estatuto -> . funcion
    (26) estatuto -> . functionCall
    (28) asignacion -> . ID EQUAL expresion
    (51) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (47) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (45) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (50) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (29) escritura -> . PRINT LPAREN escrito RPAREN
    (57) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (66) functionCall -> . funCall paren funcArgs paren
    (46) do -> . DO
    (67) funCall -> . ID

    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    FUNCTION        shift and go to state 27
    DO              shift and go to state 29

    estatutoExp                    shift and go to state 163
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    condicion                      shift and go to state 14
    whileLoop                      shift and go to state 15
    doWhile                        shift and go to state 16
    forLoop                        shift and go to state 17
    escritura                      shift and go to state 18
    funcion                        shift and go to state 19
    functionCall                   shift and go to state 20
    do                             shift and go to state 24
    funCall                        shift and go to state 28

state 163

    (16) bloqueReturn -> LCURLY declaracion estatutoExp . returnexp RCURLY
    (18) estatutoExp -> estatutoExp . estatutoExp
    (27) returnexp -> . RETURN expresion SEMICOLON
    (17) estatutoExp -> . estatuto SEMICOLON
    (18) estatutoExp -> . estatutoExp estatutoExp
    (19) estatuto -> . asignacion
    (20) estatuto -> . condicion
    (21) estatuto -> . whileLoop
    (22) estatuto -> . doWhile
    (23) estatuto -> . forLoop
    (24) estatuto -> . escritura
    (25) estatuto -> . funcion
    (26) estatuto -> . functionCall
    (28) asignacion -> . ID EQUAL expresion
    (51) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (47) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (45) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (50) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (29) escritura -> . PRINT LPAREN escrito RPAREN
    (57) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (66) functionCall -> . funCall paren funcArgs paren
    (46) do -> . DO
    (67) funCall -> . ID

    RETURN          shift and go to state 165
    ID              shift and go to state 21
    IF              shift and go to state 22
    WHILE           shift and go to state 23
    FOR             shift and go to state 25
    PRINT           shift and go to state 26
    FUNCTION        shift and go to state 27
    DO              shift and go to state 29

    estatutoExp                    shift and go to state 34
    returnexp                      shift and go to state 164
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    condicion                      shift and go to state 14
    whileLoop                      shift and go to state 15
    doWhile                        shift and go to state 16
    forLoop                        shift and go to state 17
    escritura                      shift and go to state 18
    funcion                        shift and go to state 19
    functionCall                   shift and go to state 20
    do                             shift and go to state 24
    funCall                        shift and go to state 28

state 164

    (16) bloqueReturn -> LCURLY declaracion estatutoExp returnexp . RCURLY

    RCURLY          shift and go to state 166


state 165

    (27) returnexp -> RETURN . expresion SEMICOLON
    (34) expresion -> . exp
    (35) expresion -> . condition
    (36) expresion -> . arreglo
    (37) expresion -> . functionCall
    (76) exp -> . termino
    (77) exp -> . termino signo exp
    (38) condition -> . exp comparacion expresion
    (14) arreglo -> . LBRACKET lista RBRACKET
    (66) functionCall -> . funCall paren funcArgs paren
    (80) termino -> . factor
    (81) termino -> . factor operacion termino
    (67) funCall -> . ID
    (86) factor -> . paren expresion paren
    (87) factor -> . varcte
    (88) factor -> . functionCall
    (89) paren -> . LPAREN
    (90) paren -> . RPAREN
    (92) varcte -> . ID
    (93) varcte -> . int
    (94) varcte -> . float
    (95) varcte -> . bool
    (96) varcte -> . string
    (97) int -> . INT
    (98) float -> . FLOAT
    (99) bool -> . BOOL
    (100) string -> . STRING

    LBRACKET        shift and go to state 58
    ID              shift and go to state 51
    LPAREN          shift and go to state 48
    RPAREN          shift and go to state 49
    INT             shift and go to state 66
    FLOAT           shift and go to state 67
    BOOL            shift and go to state 68
    STRING          shift and go to state 69

    expresion                      shift and go to state 167
    exp                            shift and go to state 53
    condition                      shift and go to state 54
    arreglo                        shift and go to state 55
    functionCall                   shift and go to state 56
    termino                        shift and go to state 57
    funCall                        shift and go to state 28
    paren                          shift and go to state 59
    factor                         shift and go to state 60
    varcte                         shift and go to state 61
    int                            shift and go to state 62
    float                          shift and go to state 63
    bool                           shift and go to state 64
    string                         shift and go to state 65

state 166

    (16) bloqueReturn -> LCURLY declaracion estatutoExp returnexp RCURLY .

    SEMICOLON       reduce using rule 16 (bloqueReturn -> LCURLY declaracion estatutoExp returnexp RCURLY .)


state 167

    (27) returnexp -> RETURN expresion . SEMICOLON

    SEMICOLON       shift and go to state 168


state 168

    (27) returnexp -> RETURN expresion SEMICOLON .

    RCURLY          reduce using rule 27 (returnexp -> RETURN expresion SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VAR in state 30 resolved as shift
WARNING: shift/reduce conflict for ID in state 34 resolved as shift
WARNING: shift/reduce conflict for IF in state 34 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 34 resolved as shift
WARNING: shift/reduce conflict for FOR in state 34 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 34 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 34 resolved as shift
WARNING: shift/reduce conflict for DO in state 34 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 47 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 47 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 121 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 121 resolved as shift
WARNING: shift/reduce conflict for COMA in state 135 resolved as shift
WARNING: shift/reduce conflict for COMA in state 139 resolved as shift
WARNING: reduce/reduce conflict in state 51 resolved using rule (funCall -> ID)
WARNING: rejected rule (varcte -> ID) in state 51
WARNING: reduce/reduce conflict in state 56 resolved using rule (expresion -> functionCall)
WARNING: rejected rule (factor -> functionCall) in state 56
WARNING: reduce/reduce conflict in state 80 resolved using rule (impr -> STRING)
WARNING: rejected rule (string -> STRING) in state 80
WARNING: reduce/reduce conflict in state 126 resolved using rule (funCall -> ID)
WARNING: rejected rule (varcte -> ID) in state 126
