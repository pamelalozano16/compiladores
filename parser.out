Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> START LPAREN RPAREN bloque
Rule 2     declaracion -> vars
Rule 3     declaracion -> epsilon
Rule 4     vars -> VAR var
Rule 5     vars -> vars vars
Rule 6     var -> vardef COLON tipo SEMICOLON
Rule 7     var -> declaracionArr SEMICOLON
Rule 8     var -> declaracionMatrix SEMICOLON
Rule 9     vardef -> ID
Rule 10    tipo -> INT
Rule 11    tipo -> FLOAT
Rule 12    tipo -> BOOL
Rule 13    tipo -> STRING
Rule 14    bloque -> LCURLY declaracion estatutoExp RCURLY
Rule 15    bloqueReturn -> LCURLY declaracion estatutoExp returnexp RCURLY
Rule 16    estatutoExp -> estatuto SEMICOLON
Rule 17    estatutoExp -> estatutoExp estatutoExp
Rule 18    estatuto -> asignacion
Rule 19    estatuto -> asignacionArr
Rule 20    estatuto -> condicion
Rule 21    estatuto -> whileLoop
Rule 22    estatuto -> doWhile
Rule 23    estatuto -> forLoop
Rule 24    estatuto -> escritura
Rule 25    estatuto -> funcion
Rule 26    estatuto -> functionCall
Rule 27    estatuto -> break
Rule 28    estatuto -> input
Rule 29    break -> BREAK expresion
Rule 30    returnexp -> RETURN expresion SEMICOLON
Rule 31    asignacion -> ID EQUAL expresion
Rule 32    escritura -> PRINT LPAREN escrito RPAREN
Rule 33    escrito -> impr
Rule 34    escrito -> impr COMA escrito
Rule 35    impr -> expresion
Rule 36    expresion -> exp
Rule 37    expresion -> condition
Rule 38    expresion -> functionCall
Rule 39    expresion -> arr
Rule 40    condition -> exp comparacion expresion
Rule 41    comparacion -> LESSTHAN
Rule 42    comparacion -> MORETHAN
Rule 43    comparacion -> ISEQUAL
Rule 44    comparacion -> NOTEQUAL
Rule 45    comparacion -> AND
Rule 46    comparacion -> OR
Rule 47    doWhile -> do bloque WHILE LPAREN expresion RPAREN
Rule 48    do -> DO
Rule 49    whileLoop -> WHILE startCondition expresion endCondition bloque
Rule 50    startCondition -> LPAREN
Rule 51    startCondition -> SEMICOLON
Rule 52    forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
Rule 53    condicion -> IF LPAREN expresion endCondition bloque condicionelse
Rule 54    endCondition -> RPAREN
Rule 55    endCondition -> SEMICOLON
Rule 56    condicionelse -> else bloque
Rule 57    condicionelse -> epsilon
Rule 58    else -> ELSE
Rule 59    funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
Rule 60    addArgs -> epsilon
Rule 61    funcdef -> ID
Rule 62    tiposreturn -> tiposFuncion bloqueReturn
Rule 63    tiposreturn -> VOID bloque
Rule 64    tiposFuncion -> INT
Rule 65    tiposFuncion -> FLOAT
Rule 66    tiposFuncion -> BOOL
Rule 67    tiposFuncion -> STRING
Rule 68    functionCall -> funCall lparen funcArgs rparen
Rule 69    funCall -> ID
Rule 70    funcArgs -> checkArgs
Rule 71    funcArgs -> funcArgs COMA funcArgs
Rule 72    funcArgs -> epsilon
Rule 73    checkArgs -> expresion
Rule 74    argumentos -> args
Rule 75    argumentos -> epsilon
Rule 76    args -> asignacion
Rule 77    args -> args COMA args
Rule 78    exp -> termino
Rule 79    exp -> termino signo exp
Rule 80    signo -> PLUS
Rule 81    signo -> MINUS
Rule 82    termino -> factor
Rule 83    termino -> factor operacion termino
Rule 84    operacion -> TIMES
Rule 85    operacion -> DIVIDE
Rule 86    operacion -> DIFF
Rule 87    operacion -> EXP
Rule 88    factor -> varcte
Rule 89    factor -> lparen expresion rparen
Rule 90    factor -> functionCall
Rule 91    lparen -> LPAREN
Rule 92    rparen -> RPAREN
Rule 93    epsilon -> <empty>
Rule 94    arrDef -> ID
Rule 95    declaracionArr -> arrDef LBRACKET INT RBRACKET COLON tipo
Rule 96    declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON tipo
Rule 97    asignacionArr -> arr arrayEqual expresion
Rule 98    arrayEqual -> EQUAL
Rule 99    arr -> callArr openBracket expresion abracket matrix
Rule 100   arr -> callArr openBracket expresion abracket epsilon
Rule 101   callArr -> ID
Rule 102   matrix -> openBracket expresion mbracket
Rule 103   openBracket -> LBRACKET
Rule 104   closeBracket -> RBRACKET
Rule 105   abracket -> closeBracket
Rule 106   mbracket -> closeBracket
Rule 107   input -> INPUT LPAREN ID RPAREN
Rule 108   varcte -> ID
Rule 109   varcte -> int
Rule 110   varcte -> float
Rule 111   varcte -> bool
Rule 112   varcte -> string
Rule 113   varcte -> matrix
Rule 114   varcte -> arr
Rule 115   int -> INT
Rule 116   float -> FLOAT
Rule 117   bool -> BOOL
Rule 118   string -> STRING

Terminals, with rules where they appear

AND                  : 45
BOOL                 : 12 66 117
BREAK                : 29
COLON                : 6 59 95 96
COMA                 : 34 71 77
DIFF                 : 86
DIVIDE               : 85
DO                   : 48
ELSE                 : 58
EQUAL                : 31 98
EXP                  : 87
FLOAT                : 11 65 116
FOR                  : 52
FUNCTION             : 59
ID                   : 9 31 61 69 94 101 107 108
IF                   : 53
INPUT                : 107
INT                  : 10 64 95 96 96 115
ISEQUAL              : 43
LBRACKET             : 95 96 96 103
LCURLY               : 14 15
LESSTHAN             : 41
LPAREN               : 1 32 47 50 52 53 59 91 107
MINUS                : 81
MORETHAN             : 42
NOTEQUAL             : 44
OR                   : 46
PLUS                 : 80
PRINT                : 32
RBRACKET             : 95 96 96 104
RCURLY               : 14 15
RETURN               : 30
RPAREN               : 1 32 47 52 54 59 92 107
SEMICOLON            : 6 7 8 16 30 51 55
START                : 1
STRING               : 13 67 118
TIMES                : 84
VAR                  : 4
VOID                 : 63
WHILE                : 47 49
error                : 

Nonterminals, with rules where they appear

abracket             : 99 100
addArgs              : 59
args                 : 74 77 77
argumentos           : 52
arr                  : 39 97 114
arrDef               : 95 96
arrayEqual           : 97
asignacion           : 18 52 76
asignacionArr        : 19
bloque               : 1 47 49 52 53 56 63
bloqueReturn         : 62
bool                 : 111
break                : 27
callArr              : 99 100
checkArgs            : 70
closeBracket         : 105 106
comparacion          : 40
condicion            : 20
condicionelse        : 53
condition            : 37
declaracion          : 14 15 59
declaracionArr       : 7
declaracionMatrix    : 8
do                   : 47
doWhile              : 22
else                 : 56
endCondition         : 49 52 53
epsilon              : 3 57 60 72 75 100
escrito              : 32 34
escritura            : 24
estatuto             : 16
estatutoExp          : 14 15 17 17
exp                  : 36 40 79
expresion            : 29 30 31 35 40 47 49 52 53 73 89 97 99 100 102
factor               : 82 83
float                : 110
forLoop              : 23
funCall              : 68
funcArgs             : 68 71 71
funcdef              : 59
funcion              : 25
functionCall         : 26 38 90
impr                 : 33 34
input                : 28
int                  : 109
lparen               : 68 89
matrix               : 99 113
mbracket             : 102
openBracket          : 99 100 102
operacion            : 83
programa             : 0
returnexp            : 15
rparen               : 68 89
signo                : 79
startCondition       : 49 52
string               : 112
termino              : 78 79 83
tipo                 : 6 95 96
tiposFuncion         : 62
tiposreturn          : 59
var                  : 4
varcte               : 88
vardef               : 6
vars                 : 2 5 5
whileLoop            : 21

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . START LPAREN RPAREN bloque

    START           shift and go to state 2

    programa                       shift and go to state 1

state 1

    (0) S' -> programa .



state 2

    (1) programa -> START . LPAREN RPAREN bloque

    LPAREN          shift and go to state 3


state 3

    (1) programa -> START LPAREN . RPAREN bloque

    RPAREN          shift and go to state 4


state 4

    (1) programa -> START LPAREN RPAREN . bloque
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 5

state 5

    (1) programa -> START LPAREN RPAREN bloque .

    $end            reduce using rule 1 (programa -> START LPAREN RPAREN bloque .)


state 6

    (14) bloque -> LCURLY . declaracion estatutoExp RCURLY
    (2) declaracion -> . vars
    (3) declaracion -> . epsilon
    (4) vars -> . VAR var
    (5) vars -> . vars vars
    (93) epsilon -> .

    VAR             shift and go to state 10
    ID              reduce using rule 93 (epsilon -> .)
    IF              reduce using rule 93 (epsilon -> .)
    WHILE           reduce using rule 93 (epsilon -> .)
    FOR             reduce using rule 93 (epsilon -> .)
    PRINT           reduce using rule 93 (epsilon -> .)
    FUNCTION        reduce using rule 93 (epsilon -> .)
    BREAK           reduce using rule 93 (epsilon -> .)
    INPUT           reduce using rule 93 (epsilon -> .)
    DO              reduce using rule 93 (epsilon -> .)

    declaracion                    shift and go to state 7
    vars                           shift and go to state 8
    epsilon                        shift and go to state 9

state 7

    (14) bloque -> LCURLY declaracion . estatutoExp RCURLY
    (16) estatutoExp -> . estatuto SEMICOLON
    (17) estatutoExp -> . estatutoExp estatutoExp
    (18) estatuto -> . asignacion
    (19) estatuto -> . asignacionArr
    (20) estatuto -> . condicion
    (21) estatuto -> . whileLoop
    (22) estatuto -> . doWhile
    (23) estatuto -> . forLoop
    (24) estatuto -> . escritura
    (25) estatuto -> . funcion
    (26) estatuto -> . functionCall
    (27) estatuto -> . break
    (28) estatuto -> . input
    (31) asignacion -> . ID EQUAL expresion
    (97) asignacionArr -> . arr arrayEqual expresion
    (53) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (49) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (47) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (52) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (32) escritura -> . PRINT LPAREN escrito RPAREN
    (59) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (68) functionCall -> . funCall lparen funcArgs rparen
    (29) break -> . BREAK expresion
    (107) input -> . INPUT LPAREN ID RPAREN
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (48) do -> . DO
    (69) funCall -> . ID
    (101) callArr -> . ID

    ID              shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    FUNCTION        shift and go to state 31
    BREAK           shift and go to state 33
    INPUT           shift and go to state 34
    DO              shift and go to state 36

    estatutoExp                    shift and go to state 11
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    asignacionArr                  shift and go to state 14
    condicion                      shift and go to state 15
    whileLoop                      shift and go to state 16
    doWhile                        shift and go to state 17
    forLoop                        shift and go to state 18
    escritura                      shift and go to state 19
    funcion                        shift and go to state 20
    functionCall                   shift and go to state 21
    break                          shift and go to state 22
    input                          shift and go to state 23
    arr                            shift and go to state 25
    do                             shift and go to state 28
    funCall                        shift and go to state 32
    callArr                        shift and go to state 35

state 8

    (2) declaracion -> vars .
    (5) vars -> vars . vars
    (4) vars -> . VAR var
    (5) vars -> . vars vars

    ID              reduce using rule 2 (declaracion -> vars .)
    IF              reduce using rule 2 (declaracion -> vars .)
    WHILE           reduce using rule 2 (declaracion -> vars .)
    FOR             reduce using rule 2 (declaracion -> vars .)
    PRINT           reduce using rule 2 (declaracion -> vars .)
    FUNCTION        reduce using rule 2 (declaracion -> vars .)
    BREAK           reduce using rule 2 (declaracion -> vars .)
    INPUT           reduce using rule 2 (declaracion -> vars .)
    DO              reduce using rule 2 (declaracion -> vars .)
    RPAREN          reduce using rule 2 (declaracion -> vars .)
    VAR             shift and go to state 10

    vars                           shift and go to state 37

state 9

    (3) declaracion -> epsilon .

    ID              reduce using rule 3 (declaracion -> epsilon .)
    IF              reduce using rule 3 (declaracion -> epsilon .)
    WHILE           reduce using rule 3 (declaracion -> epsilon .)
    FOR             reduce using rule 3 (declaracion -> epsilon .)
    PRINT           reduce using rule 3 (declaracion -> epsilon .)
    FUNCTION        reduce using rule 3 (declaracion -> epsilon .)
    BREAK           reduce using rule 3 (declaracion -> epsilon .)
    INPUT           reduce using rule 3 (declaracion -> epsilon .)
    DO              reduce using rule 3 (declaracion -> epsilon .)
    RPAREN          reduce using rule 3 (declaracion -> epsilon .)


state 10

    (4) vars -> VAR . var
    (6) var -> . vardef COLON tipo SEMICOLON
    (7) var -> . declaracionArr SEMICOLON
    (8) var -> . declaracionMatrix SEMICOLON
    (9) vardef -> . ID
    (95) declaracionArr -> . arrDef LBRACKET INT RBRACKET COLON tipo
    (96) declaracionMatrix -> . arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON tipo
    (94) arrDef -> . ID

    ID              shift and go to state 42

    var                            shift and go to state 38
    vardef                         shift and go to state 39
    declaracionArr                 shift and go to state 40
    declaracionMatrix              shift and go to state 41
    arrDef                         shift and go to state 43

state 11

    (14) bloque -> LCURLY declaracion estatutoExp . RCURLY
    (17) estatutoExp -> estatutoExp . estatutoExp
    (16) estatutoExp -> . estatuto SEMICOLON
    (17) estatutoExp -> . estatutoExp estatutoExp
    (18) estatuto -> . asignacion
    (19) estatuto -> . asignacionArr
    (20) estatuto -> . condicion
    (21) estatuto -> . whileLoop
    (22) estatuto -> . doWhile
    (23) estatuto -> . forLoop
    (24) estatuto -> . escritura
    (25) estatuto -> . funcion
    (26) estatuto -> . functionCall
    (27) estatuto -> . break
    (28) estatuto -> . input
    (31) asignacion -> . ID EQUAL expresion
    (97) asignacionArr -> . arr arrayEqual expresion
    (53) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (49) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (47) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (52) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (32) escritura -> . PRINT LPAREN escrito RPAREN
    (59) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (68) functionCall -> . funCall lparen funcArgs rparen
    (29) break -> . BREAK expresion
    (107) input -> . INPUT LPAREN ID RPAREN
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (48) do -> . DO
    (69) funCall -> . ID
    (101) callArr -> . ID

    RCURLY          shift and go to state 45
    ID              shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    FUNCTION        shift and go to state 31
    BREAK           shift and go to state 33
    INPUT           shift and go to state 34
    DO              shift and go to state 36

    estatutoExp                    shift and go to state 44
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    asignacionArr                  shift and go to state 14
    condicion                      shift and go to state 15
    whileLoop                      shift and go to state 16
    doWhile                        shift and go to state 17
    forLoop                        shift and go to state 18
    escritura                      shift and go to state 19
    funcion                        shift and go to state 20
    functionCall                   shift and go to state 21
    break                          shift and go to state 22
    input                          shift and go to state 23
    arr                            shift and go to state 25
    do                             shift and go to state 28
    funCall                        shift and go to state 32
    callArr                        shift and go to state 35

state 12

    (16) estatutoExp -> estatuto . SEMICOLON

    SEMICOLON       shift and go to state 46


state 13

    (18) estatuto -> asignacion .

    SEMICOLON       reduce using rule 18 (estatuto -> asignacion .)


state 14

    (19) estatuto -> asignacionArr .

    SEMICOLON       reduce using rule 19 (estatuto -> asignacionArr .)


state 15

    (20) estatuto -> condicion .

    SEMICOLON       reduce using rule 20 (estatuto -> condicion .)


state 16

    (21) estatuto -> whileLoop .

    SEMICOLON       reduce using rule 21 (estatuto -> whileLoop .)


state 17

    (22) estatuto -> doWhile .

    SEMICOLON       reduce using rule 22 (estatuto -> doWhile .)


state 18

    (23) estatuto -> forLoop .

    SEMICOLON       reduce using rule 23 (estatuto -> forLoop .)


state 19

    (24) estatuto -> escritura .

    SEMICOLON       reduce using rule 24 (estatuto -> escritura .)


state 20

    (25) estatuto -> funcion .

    SEMICOLON       reduce using rule 25 (estatuto -> funcion .)


state 21

    (26) estatuto -> functionCall .

    SEMICOLON       reduce using rule 26 (estatuto -> functionCall .)


state 22

    (27) estatuto -> break .

    SEMICOLON       reduce using rule 27 (estatuto -> break .)


state 23

    (28) estatuto -> input .

    SEMICOLON       reduce using rule 28 (estatuto -> input .)


state 24

    (31) asignacion -> ID . EQUAL expresion
    (69) funCall -> ID .
    (101) callArr -> ID .

    EQUAL           shift and go to state 47
    LPAREN          reduce using rule 69 (funCall -> ID .)
    LBRACKET        reduce using rule 101 (callArr -> ID .)


state 25

    (97) asignacionArr -> arr . arrayEqual expresion
    (98) arrayEqual -> . EQUAL

    EQUAL           shift and go to state 49

    arrayEqual                     shift and go to state 48

state 26

    (53) condicion -> IF . LPAREN expresion endCondition bloque condicionelse

    LPAREN          shift and go to state 50


state 27

    (49) whileLoop -> WHILE . startCondition expresion endCondition bloque
    (50) startCondition -> . LPAREN
    (51) startCondition -> . SEMICOLON

    LPAREN          shift and go to state 52
    SEMICOLON       shift and go to state 53

    startCondition                 shift and go to state 51

state 28

    (47) doWhile -> do . bloque WHILE LPAREN expresion RPAREN
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 54

state 29

    (52) forLoop -> FOR . LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque

    LPAREN          shift and go to state 55


state 30

    (32) escritura -> PRINT . LPAREN escrito RPAREN

    LPAREN          shift and go to state 56


state 31

    (59) funcion -> FUNCTION . funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (61) funcdef -> . ID

    ID              shift and go to state 58

    funcdef                        shift and go to state 57

state 32

    (68) functionCall -> funCall . lparen funcArgs rparen
    (91) lparen -> . LPAREN

    LPAREN          shift and go to state 60

    lparen                         shift and go to state 59

state 33

    (29) break -> BREAK . expresion
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    expresion                      shift and go to state 61
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 34

    (107) input -> INPUT . LPAREN ID RPAREN

    LPAREN          shift and go to state 82


state 35

    (99) arr -> callArr . openBracket expresion abracket matrix
    (100) arr -> callArr . openBracket expresion abracket epsilon
    (103) openBracket -> . LBRACKET

    LBRACKET        shift and go to state 81

    openBracket                    shift and go to state 83

state 36

    (48) do -> DO .

    LCURLY          reduce using rule 48 (do -> DO .)


state 37

    (5) vars -> vars vars .
    (5) vars -> vars . vars
    (4) vars -> . VAR var
    (5) vars -> . vars vars

  ! shift/reduce conflict for VAR resolved as shift
    ID              reduce using rule 5 (vars -> vars vars .)
    IF              reduce using rule 5 (vars -> vars vars .)
    WHILE           reduce using rule 5 (vars -> vars vars .)
    FOR             reduce using rule 5 (vars -> vars vars .)
    PRINT           reduce using rule 5 (vars -> vars vars .)
    FUNCTION        reduce using rule 5 (vars -> vars vars .)
    BREAK           reduce using rule 5 (vars -> vars vars .)
    INPUT           reduce using rule 5 (vars -> vars vars .)
    DO              reduce using rule 5 (vars -> vars vars .)
    RPAREN          reduce using rule 5 (vars -> vars vars .)
    VAR             shift and go to state 10

  ! VAR             [ reduce using rule 5 (vars -> vars vars .) ]

    vars                           shift and go to state 37

state 38

    (4) vars -> VAR var .

    VAR             reduce using rule 4 (vars -> VAR var .)
    ID              reduce using rule 4 (vars -> VAR var .)
    IF              reduce using rule 4 (vars -> VAR var .)
    WHILE           reduce using rule 4 (vars -> VAR var .)
    FOR             reduce using rule 4 (vars -> VAR var .)
    PRINT           reduce using rule 4 (vars -> VAR var .)
    FUNCTION        reduce using rule 4 (vars -> VAR var .)
    BREAK           reduce using rule 4 (vars -> VAR var .)
    INPUT           reduce using rule 4 (vars -> VAR var .)
    DO              reduce using rule 4 (vars -> VAR var .)
    RPAREN          reduce using rule 4 (vars -> VAR var .)


state 39

    (6) var -> vardef . COLON tipo SEMICOLON

    COLON           shift and go to state 84


state 40

    (7) var -> declaracionArr . SEMICOLON

    SEMICOLON       shift and go to state 85


state 41

    (8) var -> declaracionMatrix . SEMICOLON

    SEMICOLON       shift and go to state 86


state 42

    (9) vardef -> ID .
    (94) arrDef -> ID .

    COLON           reduce using rule 9 (vardef -> ID .)
    LBRACKET        reduce using rule 94 (arrDef -> ID .)


state 43

    (95) declaracionArr -> arrDef . LBRACKET INT RBRACKET COLON tipo
    (96) declaracionMatrix -> arrDef . LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON tipo

    LBRACKET        shift and go to state 87


state 44

    (17) estatutoExp -> estatutoExp estatutoExp .
    (17) estatutoExp -> estatutoExp . estatutoExp
    (16) estatutoExp -> . estatuto SEMICOLON
    (17) estatutoExp -> . estatutoExp estatutoExp
    (18) estatuto -> . asignacion
    (19) estatuto -> . asignacionArr
    (20) estatuto -> . condicion
    (21) estatuto -> . whileLoop
    (22) estatuto -> . doWhile
    (23) estatuto -> . forLoop
    (24) estatuto -> . escritura
    (25) estatuto -> . funcion
    (26) estatuto -> . functionCall
    (27) estatuto -> . break
    (28) estatuto -> . input
    (31) asignacion -> . ID EQUAL expresion
    (97) asignacionArr -> . arr arrayEqual expresion
    (53) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (49) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (47) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (52) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (32) escritura -> . PRINT LPAREN escrito RPAREN
    (59) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (68) functionCall -> . funCall lparen funcArgs rparen
    (29) break -> . BREAK expresion
    (107) input -> . INPUT LPAREN ID RPAREN
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (48) do -> . DO
    (69) funCall -> . ID
    (101) callArr -> . ID

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for DO resolved as shift
    RCURLY          reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .)
    RETURN          reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .)
    ID              shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    FUNCTION        shift and go to state 31
    BREAK           shift and go to state 33
    INPUT           shift and go to state 34
    DO              shift and go to state 36

  ! ID              [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! IF              [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! WHILE           [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! FOR             [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! PRINT           [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! FUNCTION        [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! BREAK           [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! INPUT           [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]
  ! DO              [ reduce using rule 17 (estatutoExp -> estatutoExp estatutoExp .) ]

    estatutoExp                    shift and go to state 44
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    asignacionArr                  shift and go to state 14
    condicion                      shift and go to state 15
    whileLoop                      shift and go to state 16
    doWhile                        shift and go to state 17
    forLoop                        shift and go to state 18
    escritura                      shift and go to state 19
    funcion                        shift and go to state 20
    functionCall                   shift and go to state 21
    break                          shift and go to state 22
    input                          shift and go to state 23
    arr                            shift and go to state 25
    do                             shift and go to state 28
    funCall                        shift and go to state 32
    callArr                        shift and go to state 35

state 45

    (14) bloque -> LCURLY declaracion estatutoExp RCURLY .

    $end            reduce using rule 14 (bloque -> LCURLY declaracion estatutoExp RCURLY .)
    WHILE           reduce using rule 14 (bloque -> LCURLY declaracion estatutoExp RCURLY .)
    ELSE            reduce using rule 14 (bloque -> LCURLY declaracion estatutoExp RCURLY .)
    SEMICOLON       reduce using rule 14 (bloque -> LCURLY declaracion estatutoExp RCURLY .)


state 46

    (16) estatutoExp -> estatuto SEMICOLON .

    RCURLY          reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    ID              reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    IF              reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    WHILE           reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    FOR             reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    PRINT           reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    FUNCTION        reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    BREAK           reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    INPUT           reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    DO              reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)
    RETURN          reduce using rule 16 (estatutoExp -> estatuto SEMICOLON .)


state 47

    (31) asignacion -> ID EQUAL . expresion
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    expresion                      shift and go to state 88
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 48

    (97) asignacionArr -> arr arrayEqual . expresion
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    arr                            shift and go to state 65
    expresion                      shift and go to state 89
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 49

    (98) arrayEqual -> EQUAL .

    ID              reduce using rule 98 (arrayEqual -> EQUAL .)
    LPAREN          reduce using rule 98 (arrayEqual -> EQUAL .)
    INT             reduce using rule 98 (arrayEqual -> EQUAL .)
    FLOAT           reduce using rule 98 (arrayEqual -> EQUAL .)
    BOOL            reduce using rule 98 (arrayEqual -> EQUAL .)
    STRING          reduce using rule 98 (arrayEqual -> EQUAL .)
    LBRACKET        reduce using rule 98 (arrayEqual -> EQUAL .)


state 50

    (53) condicion -> IF LPAREN . expresion endCondition bloque condicionelse
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    expresion                      shift and go to state 90
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 51

    (49) whileLoop -> WHILE startCondition . expresion endCondition bloque
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    expresion                      shift and go to state 91
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 52

    (50) startCondition -> LPAREN .

    ID              reduce using rule 50 (startCondition -> LPAREN .)
    LPAREN          reduce using rule 50 (startCondition -> LPAREN .)
    INT             reduce using rule 50 (startCondition -> LPAREN .)
    FLOAT           reduce using rule 50 (startCondition -> LPAREN .)
    BOOL            reduce using rule 50 (startCondition -> LPAREN .)
    STRING          reduce using rule 50 (startCondition -> LPAREN .)
    LBRACKET        reduce using rule 50 (startCondition -> LPAREN .)


state 53

    (51) startCondition -> SEMICOLON .

    ID              reduce using rule 51 (startCondition -> SEMICOLON .)
    LPAREN          reduce using rule 51 (startCondition -> SEMICOLON .)
    INT             reduce using rule 51 (startCondition -> SEMICOLON .)
    FLOAT           reduce using rule 51 (startCondition -> SEMICOLON .)
    BOOL            reduce using rule 51 (startCondition -> SEMICOLON .)
    STRING          reduce using rule 51 (startCondition -> SEMICOLON .)
    LBRACKET        reduce using rule 51 (startCondition -> SEMICOLON .)


state 54

    (47) doWhile -> do bloque . WHILE LPAREN expresion RPAREN

    WHILE           shift and go to state 92


state 55

    (52) forLoop -> FOR LPAREN . argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (74) argumentos -> . args
    (75) argumentos -> . epsilon
    (76) args -> . asignacion
    (77) args -> . args COMA args
    (93) epsilon -> .
    (31) asignacion -> . ID EQUAL expresion

    LPAREN          reduce using rule 93 (epsilon -> .)
    SEMICOLON       reduce using rule 93 (epsilon -> .)
    ID              shift and go to state 97

    argumentos                     shift and go to state 93
    asignacion                     shift and go to state 94
    args                           shift and go to state 95
    epsilon                        shift and go to state 96

state 56

    (32) escritura -> PRINT LPAREN . escrito RPAREN
    (33) escrito -> . impr
    (34) escrito -> . impr COMA escrito
    (35) impr -> . expresion
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    escrito                        shift and go to state 98
    impr                           shift and go to state 99
    expresion                      shift and go to state 100
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 57

    (59) funcion -> FUNCTION funcdef . LPAREN declaracion addArgs RPAREN COLON tiposreturn

    LPAREN          shift and go to state 101


state 58

    (61) funcdef -> ID .

    LPAREN          reduce using rule 61 (funcdef -> ID .)


state 59

    (68) functionCall -> funCall lparen . funcArgs rparen
    (70) funcArgs -> . checkArgs
    (71) funcArgs -> . funcArgs COMA funcArgs
    (72) funcArgs -> . epsilon
    (73) checkArgs -> . expresion
    (93) epsilon -> .
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    COMA            reduce using rule 93 (epsilon -> .)
    RPAREN          reduce using rule 93 (epsilon -> .)
    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    funcArgs                       shift and go to state 102
    checkArgs                      shift and go to state 103
    epsilon                        shift and go to state 104
    expresion                      shift and go to state 105
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 60

    (91) lparen -> LPAREN .

    ID              reduce using rule 91 (lparen -> LPAREN .)
    LPAREN          reduce using rule 91 (lparen -> LPAREN .)
    INT             reduce using rule 91 (lparen -> LPAREN .)
    FLOAT           reduce using rule 91 (lparen -> LPAREN .)
    BOOL            reduce using rule 91 (lparen -> LPAREN .)
    STRING          reduce using rule 91 (lparen -> LPAREN .)
    LBRACKET        reduce using rule 91 (lparen -> LPAREN .)
    COMA            reduce using rule 91 (lparen -> LPAREN .)
    RPAREN          reduce using rule 91 (lparen -> LPAREN .)


state 61

    (29) break -> BREAK expresion .

    SEMICOLON       reduce using rule 29 (break -> BREAK expresion .)


state 62

    (36) expresion -> exp .
    (40) condition -> exp . comparacion expresion
    (41) comparacion -> . LESSTHAN
    (42) comparacion -> . MORETHAN
    (43) comparacion -> . ISEQUAL
    (44) comparacion -> . NOTEQUAL
    (45) comparacion -> . AND
    (46) comparacion -> . OR

    SEMICOLON       reduce using rule 36 (expresion -> exp .)
    COMA            reduce using rule 36 (expresion -> exp .)
    LPAREN          reduce using rule 36 (expresion -> exp .)
    RPAREN          reduce using rule 36 (expresion -> exp .)
    RBRACKET        reduce using rule 36 (expresion -> exp .)
    LESSTHAN        shift and go to state 107
    MORETHAN        shift and go to state 108
    ISEQUAL         shift and go to state 109
    NOTEQUAL        shift and go to state 110
    AND             shift and go to state 111
    OR              shift and go to state 112

    comparacion                    shift and go to state 106

state 63

    (37) expresion -> condition .

    SEMICOLON       reduce using rule 37 (expresion -> condition .)
    COMA            reduce using rule 37 (expresion -> condition .)
    LPAREN          reduce using rule 37 (expresion -> condition .)
    RPAREN          reduce using rule 37 (expresion -> condition .)
    RBRACKET        reduce using rule 37 (expresion -> condition .)


state 64

    (38) expresion -> functionCall .
    (90) factor -> functionCall .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 38 (expresion -> functionCall .)
  ! reduce/reduce conflict for COMA resolved using rule 38 (expresion -> functionCall .)
  ! reduce/reduce conflict for LPAREN resolved using rule 38 (expresion -> functionCall .)
  ! reduce/reduce conflict for RPAREN resolved using rule 38 (expresion -> functionCall .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 38 (expresion -> functionCall .)
    SEMICOLON       reduce using rule 38 (expresion -> functionCall .)
    COMA            reduce using rule 38 (expresion -> functionCall .)
    LPAREN          reduce using rule 38 (expresion -> functionCall .)
    RPAREN          reduce using rule 38 (expresion -> functionCall .)
    RBRACKET        reduce using rule 38 (expresion -> functionCall .)
    TIMES           reduce using rule 90 (factor -> functionCall .)
    DIVIDE          reduce using rule 90 (factor -> functionCall .)
    DIFF            reduce using rule 90 (factor -> functionCall .)
    EXP             reduce using rule 90 (factor -> functionCall .)
    PLUS            reduce using rule 90 (factor -> functionCall .)
    MINUS           reduce using rule 90 (factor -> functionCall .)
    LESSTHAN        reduce using rule 90 (factor -> functionCall .)
    MORETHAN        reduce using rule 90 (factor -> functionCall .)
    ISEQUAL         reduce using rule 90 (factor -> functionCall .)
    NOTEQUAL        reduce using rule 90 (factor -> functionCall .)
    AND             reduce using rule 90 (factor -> functionCall .)
    OR              reduce using rule 90 (factor -> functionCall .)

  ! SEMICOLON       [ reduce using rule 90 (factor -> functionCall .) ]
  ! COMA            [ reduce using rule 90 (factor -> functionCall .) ]
  ! LPAREN          [ reduce using rule 90 (factor -> functionCall .) ]
  ! RPAREN          [ reduce using rule 90 (factor -> functionCall .) ]
  ! RBRACKET        [ reduce using rule 90 (factor -> functionCall .) ]


state 65

    (39) expresion -> arr .
    (114) varcte -> arr .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 39 (expresion -> arr .)
  ! reduce/reduce conflict for COMA resolved using rule 39 (expresion -> arr .)
  ! reduce/reduce conflict for LPAREN resolved using rule 39 (expresion -> arr .)
  ! reduce/reduce conflict for RPAREN resolved using rule 39 (expresion -> arr .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 39 (expresion -> arr .)
    SEMICOLON       reduce using rule 39 (expresion -> arr .)
    COMA            reduce using rule 39 (expresion -> arr .)
    LPAREN          reduce using rule 39 (expresion -> arr .)
    RPAREN          reduce using rule 39 (expresion -> arr .)
    RBRACKET        reduce using rule 39 (expresion -> arr .)
    TIMES           reduce using rule 114 (varcte -> arr .)
    DIVIDE          reduce using rule 114 (varcte -> arr .)
    DIFF            reduce using rule 114 (varcte -> arr .)
    EXP             reduce using rule 114 (varcte -> arr .)
    PLUS            reduce using rule 114 (varcte -> arr .)
    MINUS           reduce using rule 114 (varcte -> arr .)
    LESSTHAN        reduce using rule 114 (varcte -> arr .)
    MORETHAN        reduce using rule 114 (varcte -> arr .)
    ISEQUAL         reduce using rule 114 (varcte -> arr .)
    NOTEQUAL        reduce using rule 114 (varcte -> arr .)
    AND             reduce using rule 114 (varcte -> arr .)
    OR              reduce using rule 114 (varcte -> arr .)

  ! SEMICOLON       [ reduce using rule 114 (varcte -> arr .) ]
  ! COMA            [ reduce using rule 114 (varcte -> arr .) ]
  ! LPAREN          [ reduce using rule 114 (varcte -> arr .) ]
  ! RPAREN          [ reduce using rule 114 (varcte -> arr .) ]
  ! RBRACKET        [ reduce using rule 114 (varcte -> arr .) ]


state 66

    (78) exp -> termino .
    (79) exp -> termino . signo exp
    (80) signo -> . PLUS
    (81) signo -> . MINUS

    LESSTHAN        reduce using rule 78 (exp -> termino .)
    MORETHAN        reduce using rule 78 (exp -> termino .)
    ISEQUAL         reduce using rule 78 (exp -> termino .)
    NOTEQUAL        reduce using rule 78 (exp -> termino .)
    AND             reduce using rule 78 (exp -> termino .)
    OR              reduce using rule 78 (exp -> termino .)
    SEMICOLON       reduce using rule 78 (exp -> termino .)
    COMA            reduce using rule 78 (exp -> termino .)
    LPAREN          reduce using rule 78 (exp -> termino .)
    RPAREN          reduce using rule 78 (exp -> termino .)
    RBRACKET        reduce using rule 78 (exp -> termino .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115

    signo                          shift and go to state 113

state 67

    (89) factor -> lparen . expresion rparen
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    lparen                         shift and go to state 67
    expresion                      shift and go to state 116
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 68

    (102) matrix -> openBracket . expresion mbracket
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    openBracket                    shift and go to state 68
    expresion                      shift and go to state 117
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 69

    (113) varcte -> matrix .

    TIMES           reduce using rule 113 (varcte -> matrix .)
    DIVIDE          reduce using rule 113 (varcte -> matrix .)
    DIFF            reduce using rule 113 (varcte -> matrix .)
    EXP             reduce using rule 113 (varcte -> matrix .)
    PLUS            reduce using rule 113 (varcte -> matrix .)
    MINUS           reduce using rule 113 (varcte -> matrix .)
    LESSTHAN        reduce using rule 113 (varcte -> matrix .)
    MORETHAN        reduce using rule 113 (varcte -> matrix .)
    ISEQUAL         reduce using rule 113 (varcte -> matrix .)
    NOTEQUAL        reduce using rule 113 (varcte -> matrix .)
    AND             reduce using rule 113 (varcte -> matrix .)
    OR              reduce using rule 113 (varcte -> matrix .)
    SEMICOLON       reduce using rule 113 (varcte -> matrix .)
    COMA            reduce using rule 113 (varcte -> matrix .)
    LPAREN          reduce using rule 113 (varcte -> matrix .)
    RPAREN          reduce using rule 113 (varcte -> matrix .)
    RBRACKET        reduce using rule 113 (varcte -> matrix .)


state 70

    (82) termino -> factor .
    (83) termino -> factor . operacion termino
    (84) operacion -> . TIMES
    (85) operacion -> . DIVIDE
    (86) operacion -> . DIFF
    (87) operacion -> . EXP

    PLUS            reduce using rule 82 (termino -> factor .)
    MINUS           reduce using rule 82 (termino -> factor .)
    LESSTHAN        reduce using rule 82 (termino -> factor .)
    MORETHAN        reduce using rule 82 (termino -> factor .)
    ISEQUAL         reduce using rule 82 (termino -> factor .)
    NOTEQUAL        reduce using rule 82 (termino -> factor .)
    AND             reduce using rule 82 (termino -> factor .)
    OR              reduce using rule 82 (termino -> factor .)
    SEMICOLON       reduce using rule 82 (termino -> factor .)
    COMA            reduce using rule 82 (termino -> factor .)
    LPAREN          reduce using rule 82 (termino -> factor .)
    RPAREN          reduce using rule 82 (termino -> factor .)
    RBRACKET        reduce using rule 82 (termino -> factor .)
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    DIFF            shift and go to state 121
    EXP             shift and go to state 122

    operacion                      shift and go to state 118

state 71

    (69) funCall -> ID .
    (101) callArr -> ID .
    (108) varcte -> ID .

  ! reduce/reduce conflict for LPAREN resolved using rule 69 (funCall -> ID .)
    LPAREN          reduce using rule 69 (funCall -> ID .)
    LBRACKET        reduce using rule 101 (callArr -> ID .)
    TIMES           reduce using rule 108 (varcte -> ID .)
    DIVIDE          reduce using rule 108 (varcte -> ID .)
    DIFF            reduce using rule 108 (varcte -> ID .)
    EXP             reduce using rule 108 (varcte -> ID .)
    PLUS            reduce using rule 108 (varcte -> ID .)
    MINUS           reduce using rule 108 (varcte -> ID .)
    LESSTHAN        reduce using rule 108 (varcte -> ID .)
    MORETHAN        reduce using rule 108 (varcte -> ID .)
    ISEQUAL         reduce using rule 108 (varcte -> ID .)
    NOTEQUAL        reduce using rule 108 (varcte -> ID .)
    AND             reduce using rule 108 (varcte -> ID .)
    OR              reduce using rule 108 (varcte -> ID .)
    SEMICOLON       reduce using rule 108 (varcte -> ID .)
    COMA            reduce using rule 108 (varcte -> ID .)
    RPAREN          reduce using rule 108 (varcte -> ID .)
    RBRACKET        reduce using rule 108 (varcte -> ID .)

  ! LPAREN          [ reduce using rule 108 (varcte -> ID .) ]


state 72

    (88) factor -> varcte .

    TIMES           reduce using rule 88 (factor -> varcte .)
    DIVIDE          reduce using rule 88 (factor -> varcte .)
    DIFF            reduce using rule 88 (factor -> varcte .)
    EXP             reduce using rule 88 (factor -> varcte .)
    PLUS            reduce using rule 88 (factor -> varcte .)
    MINUS           reduce using rule 88 (factor -> varcte .)
    LESSTHAN        reduce using rule 88 (factor -> varcte .)
    MORETHAN        reduce using rule 88 (factor -> varcte .)
    ISEQUAL         reduce using rule 88 (factor -> varcte .)
    NOTEQUAL        reduce using rule 88 (factor -> varcte .)
    AND             reduce using rule 88 (factor -> varcte .)
    OR              reduce using rule 88 (factor -> varcte .)
    SEMICOLON       reduce using rule 88 (factor -> varcte .)
    COMA            reduce using rule 88 (factor -> varcte .)
    LPAREN          reduce using rule 88 (factor -> varcte .)
    RPAREN          reduce using rule 88 (factor -> varcte .)
    RBRACKET        reduce using rule 88 (factor -> varcte .)


state 73

    (109) varcte -> int .

    TIMES           reduce using rule 109 (varcte -> int .)
    DIVIDE          reduce using rule 109 (varcte -> int .)
    DIFF            reduce using rule 109 (varcte -> int .)
    EXP             reduce using rule 109 (varcte -> int .)
    PLUS            reduce using rule 109 (varcte -> int .)
    MINUS           reduce using rule 109 (varcte -> int .)
    LESSTHAN        reduce using rule 109 (varcte -> int .)
    MORETHAN        reduce using rule 109 (varcte -> int .)
    ISEQUAL         reduce using rule 109 (varcte -> int .)
    NOTEQUAL        reduce using rule 109 (varcte -> int .)
    AND             reduce using rule 109 (varcte -> int .)
    OR              reduce using rule 109 (varcte -> int .)
    SEMICOLON       reduce using rule 109 (varcte -> int .)
    COMA            reduce using rule 109 (varcte -> int .)
    LPAREN          reduce using rule 109 (varcte -> int .)
    RPAREN          reduce using rule 109 (varcte -> int .)
    RBRACKET        reduce using rule 109 (varcte -> int .)


state 74

    (110) varcte -> float .

    TIMES           reduce using rule 110 (varcte -> float .)
    DIVIDE          reduce using rule 110 (varcte -> float .)
    DIFF            reduce using rule 110 (varcte -> float .)
    EXP             reduce using rule 110 (varcte -> float .)
    PLUS            reduce using rule 110 (varcte -> float .)
    MINUS           reduce using rule 110 (varcte -> float .)
    LESSTHAN        reduce using rule 110 (varcte -> float .)
    MORETHAN        reduce using rule 110 (varcte -> float .)
    ISEQUAL         reduce using rule 110 (varcte -> float .)
    NOTEQUAL        reduce using rule 110 (varcte -> float .)
    AND             reduce using rule 110 (varcte -> float .)
    OR              reduce using rule 110 (varcte -> float .)
    SEMICOLON       reduce using rule 110 (varcte -> float .)
    COMA            reduce using rule 110 (varcte -> float .)
    LPAREN          reduce using rule 110 (varcte -> float .)
    RPAREN          reduce using rule 110 (varcte -> float .)
    RBRACKET        reduce using rule 110 (varcte -> float .)


state 75

    (111) varcte -> bool .

    TIMES           reduce using rule 111 (varcte -> bool .)
    DIVIDE          reduce using rule 111 (varcte -> bool .)
    DIFF            reduce using rule 111 (varcte -> bool .)
    EXP             reduce using rule 111 (varcte -> bool .)
    PLUS            reduce using rule 111 (varcte -> bool .)
    MINUS           reduce using rule 111 (varcte -> bool .)
    LESSTHAN        reduce using rule 111 (varcte -> bool .)
    MORETHAN        reduce using rule 111 (varcte -> bool .)
    ISEQUAL         reduce using rule 111 (varcte -> bool .)
    NOTEQUAL        reduce using rule 111 (varcte -> bool .)
    AND             reduce using rule 111 (varcte -> bool .)
    OR              reduce using rule 111 (varcte -> bool .)
    SEMICOLON       reduce using rule 111 (varcte -> bool .)
    COMA            reduce using rule 111 (varcte -> bool .)
    LPAREN          reduce using rule 111 (varcte -> bool .)
    RPAREN          reduce using rule 111 (varcte -> bool .)
    RBRACKET        reduce using rule 111 (varcte -> bool .)


state 76

    (112) varcte -> string .

    TIMES           reduce using rule 112 (varcte -> string .)
    DIVIDE          reduce using rule 112 (varcte -> string .)
    DIFF            reduce using rule 112 (varcte -> string .)
    EXP             reduce using rule 112 (varcte -> string .)
    PLUS            reduce using rule 112 (varcte -> string .)
    MINUS           reduce using rule 112 (varcte -> string .)
    LESSTHAN        reduce using rule 112 (varcte -> string .)
    MORETHAN        reduce using rule 112 (varcte -> string .)
    ISEQUAL         reduce using rule 112 (varcte -> string .)
    NOTEQUAL        reduce using rule 112 (varcte -> string .)
    AND             reduce using rule 112 (varcte -> string .)
    OR              reduce using rule 112 (varcte -> string .)
    SEMICOLON       reduce using rule 112 (varcte -> string .)
    COMA            reduce using rule 112 (varcte -> string .)
    LPAREN          reduce using rule 112 (varcte -> string .)
    RPAREN          reduce using rule 112 (varcte -> string .)
    RBRACKET        reduce using rule 112 (varcte -> string .)


state 77

    (115) int -> INT .

    TIMES           reduce using rule 115 (int -> INT .)
    DIVIDE          reduce using rule 115 (int -> INT .)
    DIFF            reduce using rule 115 (int -> INT .)
    EXP             reduce using rule 115 (int -> INT .)
    PLUS            reduce using rule 115 (int -> INT .)
    MINUS           reduce using rule 115 (int -> INT .)
    LESSTHAN        reduce using rule 115 (int -> INT .)
    MORETHAN        reduce using rule 115 (int -> INT .)
    ISEQUAL         reduce using rule 115 (int -> INT .)
    NOTEQUAL        reduce using rule 115 (int -> INT .)
    AND             reduce using rule 115 (int -> INT .)
    OR              reduce using rule 115 (int -> INT .)
    SEMICOLON       reduce using rule 115 (int -> INT .)
    COMA            reduce using rule 115 (int -> INT .)
    LPAREN          reduce using rule 115 (int -> INT .)
    RPAREN          reduce using rule 115 (int -> INT .)
    RBRACKET        reduce using rule 115 (int -> INT .)


state 78

    (116) float -> FLOAT .

    TIMES           reduce using rule 116 (float -> FLOAT .)
    DIVIDE          reduce using rule 116 (float -> FLOAT .)
    DIFF            reduce using rule 116 (float -> FLOAT .)
    EXP             reduce using rule 116 (float -> FLOAT .)
    PLUS            reduce using rule 116 (float -> FLOAT .)
    MINUS           reduce using rule 116 (float -> FLOAT .)
    LESSTHAN        reduce using rule 116 (float -> FLOAT .)
    MORETHAN        reduce using rule 116 (float -> FLOAT .)
    ISEQUAL         reduce using rule 116 (float -> FLOAT .)
    NOTEQUAL        reduce using rule 116 (float -> FLOAT .)
    AND             reduce using rule 116 (float -> FLOAT .)
    OR              reduce using rule 116 (float -> FLOAT .)
    SEMICOLON       reduce using rule 116 (float -> FLOAT .)
    COMA            reduce using rule 116 (float -> FLOAT .)
    LPAREN          reduce using rule 116 (float -> FLOAT .)
    RPAREN          reduce using rule 116 (float -> FLOAT .)
    RBRACKET        reduce using rule 116 (float -> FLOAT .)


state 79

    (117) bool -> BOOL .

    TIMES           reduce using rule 117 (bool -> BOOL .)
    DIVIDE          reduce using rule 117 (bool -> BOOL .)
    DIFF            reduce using rule 117 (bool -> BOOL .)
    EXP             reduce using rule 117 (bool -> BOOL .)
    PLUS            reduce using rule 117 (bool -> BOOL .)
    MINUS           reduce using rule 117 (bool -> BOOL .)
    LESSTHAN        reduce using rule 117 (bool -> BOOL .)
    MORETHAN        reduce using rule 117 (bool -> BOOL .)
    ISEQUAL         reduce using rule 117 (bool -> BOOL .)
    NOTEQUAL        reduce using rule 117 (bool -> BOOL .)
    AND             reduce using rule 117 (bool -> BOOL .)
    OR              reduce using rule 117 (bool -> BOOL .)
    SEMICOLON       reduce using rule 117 (bool -> BOOL .)
    COMA            reduce using rule 117 (bool -> BOOL .)
    LPAREN          reduce using rule 117 (bool -> BOOL .)
    RPAREN          reduce using rule 117 (bool -> BOOL .)
    RBRACKET        reduce using rule 117 (bool -> BOOL .)


state 80

    (118) string -> STRING .

    TIMES           reduce using rule 118 (string -> STRING .)
    DIVIDE          reduce using rule 118 (string -> STRING .)
    DIFF            reduce using rule 118 (string -> STRING .)
    EXP             reduce using rule 118 (string -> STRING .)
    PLUS            reduce using rule 118 (string -> STRING .)
    MINUS           reduce using rule 118 (string -> STRING .)
    LESSTHAN        reduce using rule 118 (string -> STRING .)
    MORETHAN        reduce using rule 118 (string -> STRING .)
    ISEQUAL         reduce using rule 118 (string -> STRING .)
    NOTEQUAL        reduce using rule 118 (string -> STRING .)
    AND             reduce using rule 118 (string -> STRING .)
    OR              reduce using rule 118 (string -> STRING .)
    SEMICOLON       reduce using rule 118 (string -> STRING .)
    COMA            reduce using rule 118 (string -> STRING .)
    LPAREN          reduce using rule 118 (string -> STRING .)
    RPAREN          reduce using rule 118 (string -> STRING .)
    RBRACKET        reduce using rule 118 (string -> STRING .)


state 81

    (103) openBracket -> LBRACKET .

    ID              reduce using rule 103 (openBracket -> LBRACKET .)
    LPAREN          reduce using rule 103 (openBracket -> LBRACKET .)
    INT             reduce using rule 103 (openBracket -> LBRACKET .)
    FLOAT           reduce using rule 103 (openBracket -> LBRACKET .)
    BOOL            reduce using rule 103 (openBracket -> LBRACKET .)
    STRING          reduce using rule 103 (openBracket -> LBRACKET .)
    LBRACKET        reduce using rule 103 (openBracket -> LBRACKET .)


state 82

    (107) input -> INPUT LPAREN . ID RPAREN

    ID              shift and go to state 123


state 83

    (99) arr -> callArr openBracket . expresion abracket matrix
    (100) arr -> callArr openBracket . expresion abracket epsilon
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    expresion                      shift and go to state 124
    matrix                         shift and go to state 69
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 84

    (6) var -> vardef COLON . tipo SEMICOLON
    (10) tipo -> . INT
    (11) tipo -> . FLOAT
    (12) tipo -> . BOOL
    (13) tipo -> . STRING

    INT             shift and go to state 126
    FLOAT           shift and go to state 127
    BOOL            shift and go to state 128
    STRING          shift and go to state 129

    tipo                           shift and go to state 125

state 85

    (7) var -> declaracionArr SEMICOLON .

    VAR             reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    ID              reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    IF              reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    WHILE           reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    FOR             reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    PRINT           reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    FUNCTION        reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    BREAK           reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    INPUT           reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    DO              reduce using rule 7 (var -> declaracionArr SEMICOLON .)
    RPAREN          reduce using rule 7 (var -> declaracionArr SEMICOLON .)


state 86

    (8) var -> declaracionMatrix SEMICOLON .

    VAR             reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    ID              reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    IF              reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    WHILE           reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    FOR             reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    PRINT           reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    FUNCTION        reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    BREAK           reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    INPUT           reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    DO              reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)
    RPAREN          reduce using rule 8 (var -> declaracionMatrix SEMICOLON .)


state 87

    (95) declaracionArr -> arrDef LBRACKET . INT RBRACKET COLON tipo
    (96) declaracionMatrix -> arrDef LBRACKET . INT RBRACKET LBRACKET INT RBRACKET COLON tipo

    INT             shift and go to state 130


state 88

    (31) asignacion -> ID EQUAL expresion .

    SEMICOLON       reduce using rule 31 (asignacion -> ID EQUAL expresion .)
    COMA            reduce using rule 31 (asignacion -> ID EQUAL expresion .)
    LPAREN          reduce using rule 31 (asignacion -> ID EQUAL expresion .)
    RPAREN          reduce using rule 31 (asignacion -> ID EQUAL expresion .)


state 89

    (97) asignacionArr -> arr arrayEqual expresion .

    SEMICOLON       reduce using rule 97 (asignacionArr -> arr arrayEqual expresion .)


state 90

    (53) condicion -> IF LPAREN expresion . endCondition bloque condicionelse
    (54) endCondition -> . RPAREN
    (55) endCondition -> . SEMICOLON

    RPAREN          shift and go to state 132
    SEMICOLON       shift and go to state 133

    endCondition                   shift and go to state 131

state 91

    (49) whileLoop -> WHILE startCondition expresion . endCondition bloque
    (54) endCondition -> . RPAREN
    (55) endCondition -> . SEMICOLON

    RPAREN          shift and go to state 132
    SEMICOLON       shift and go to state 133

    endCondition                   shift and go to state 134

state 92

    (47) doWhile -> do bloque WHILE . LPAREN expresion RPAREN

    LPAREN          shift and go to state 135


state 93

    (52) forLoop -> FOR LPAREN argumentos . startCondition expresion endCondition asignacion RPAREN bloque
    (50) startCondition -> . LPAREN
    (51) startCondition -> . SEMICOLON

    LPAREN          shift and go to state 52
    SEMICOLON       shift and go to state 53

    startCondition                 shift and go to state 136

state 94

    (76) args -> asignacion .

    COMA            reduce using rule 76 (args -> asignacion .)
    LPAREN          reduce using rule 76 (args -> asignacion .)
    SEMICOLON       reduce using rule 76 (args -> asignacion .)


state 95

    (74) argumentos -> args .
    (77) args -> args . COMA args

    LPAREN          reduce using rule 74 (argumentos -> args .)
    SEMICOLON       reduce using rule 74 (argumentos -> args .)
    COMA            shift and go to state 137


state 96

    (75) argumentos -> epsilon .

    LPAREN          reduce using rule 75 (argumentos -> epsilon .)
    SEMICOLON       reduce using rule 75 (argumentos -> epsilon .)


state 97

    (31) asignacion -> ID . EQUAL expresion

    EQUAL           shift and go to state 47


state 98

    (32) escritura -> PRINT LPAREN escrito . RPAREN

    RPAREN          shift and go to state 138


state 99

    (33) escrito -> impr .
    (34) escrito -> impr . COMA escrito

    RPAREN          reduce using rule 33 (escrito -> impr .)
    COMA            shift and go to state 139


state 100

    (35) impr -> expresion .

    COMA            reduce using rule 35 (impr -> expresion .)
    RPAREN          reduce using rule 35 (impr -> expresion .)


state 101

    (59) funcion -> FUNCTION funcdef LPAREN . declaracion addArgs RPAREN COLON tiposreturn
    (2) declaracion -> . vars
    (3) declaracion -> . epsilon
    (4) vars -> . VAR var
    (5) vars -> . vars vars
    (93) epsilon -> .

    VAR             shift and go to state 10
    RPAREN          reduce using rule 93 (epsilon -> .)

    declaracion                    shift and go to state 140
    vars                           shift and go to state 8
    epsilon                        shift and go to state 9

state 102

    (68) functionCall -> funCall lparen funcArgs . rparen
    (71) funcArgs -> funcArgs . COMA funcArgs
    (92) rparen -> . RPAREN

    COMA            shift and go to state 142
    RPAREN          shift and go to state 143

    rparen                         shift and go to state 141

state 103

    (70) funcArgs -> checkArgs .

    COMA            reduce using rule 70 (funcArgs -> checkArgs .)
    RPAREN          reduce using rule 70 (funcArgs -> checkArgs .)


state 104

    (72) funcArgs -> epsilon .

    COMA            reduce using rule 72 (funcArgs -> epsilon .)
    RPAREN          reduce using rule 72 (funcArgs -> epsilon .)


state 105

    (73) checkArgs -> expresion .

    COMA            reduce using rule 73 (checkArgs -> expresion .)
    RPAREN          reduce using rule 73 (checkArgs -> expresion .)


state 106

    (40) condition -> exp comparacion . expresion
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    exp                            shift and go to state 62
    expresion                      shift and go to state 144
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 107

    (41) comparacion -> LESSTHAN .

    ID              reduce using rule 41 (comparacion -> LESSTHAN .)
    LPAREN          reduce using rule 41 (comparacion -> LESSTHAN .)
    INT             reduce using rule 41 (comparacion -> LESSTHAN .)
    FLOAT           reduce using rule 41 (comparacion -> LESSTHAN .)
    BOOL            reduce using rule 41 (comparacion -> LESSTHAN .)
    STRING          reduce using rule 41 (comparacion -> LESSTHAN .)
    LBRACKET        reduce using rule 41 (comparacion -> LESSTHAN .)


state 108

    (42) comparacion -> MORETHAN .

    ID              reduce using rule 42 (comparacion -> MORETHAN .)
    LPAREN          reduce using rule 42 (comparacion -> MORETHAN .)
    INT             reduce using rule 42 (comparacion -> MORETHAN .)
    FLOAT           reduce using rule 42 (comparacion -> MORETHAN .)
    BOOL            reduce using rule 42 (comparacion -> MORETHAN .)
    STRING          reduce using rule 42 (comparacion -> MORETHAN .)
    LBRACKET        reduce using rule 42 (comparacion -> MORETHAN .)


state 109

    (43) comparacion -> ISEQUAL .

    ID              reduce using rule 43 (comparacion -> ISEQUAL .)
    LPAREN          reduce using rule 43 (comparacion -> ISEQUAL .)
    INT             reduce using rule 43 (comparacion -> ISEQUAL .)
    FLOAT           reduce using rule 43 (comparacion -> ISEQUAL .)
    BOOL            reduce using rule 43 (comparacion -> ISEQUAL .)
    STRING          reduce using rule 43 (comparacion -> ISEQUAL .)
    LBRACKET        reduce using rule 43 (comparacion -> ISEQUAL .)


state 110

    (44) comparacion -> NOTEQUAL .

    ID              reduce using rule 44 (comparacion -> NOTEQUAL .)
    LPAREN          reduce using rule 44 (comparacion -> NOTEQUAL .)
    INT             reduce using rule 44 (comparacion -> NOTEQUAL .)
    FLOAT           reduce using rule 44 (comparacion -> NOTEQUAL .)
    BOOL            reduce using rule 44 (comparacion -> NOTEQUAL .)
    STRING          reduce using rule 44 (comparacion -> NOTEQUAL .)
    LBRACKET        reduce using rule 44 (comparacion -> NOTEQUAL .)


state 111

    (45) comparacion -> AND .

    ID              reduce using rule 45 (comparacion -> AND .)
    LPAREN          reduce using rule 45 (comparacion -> AND .)
    INT             reduce using rule 45 (comparacion -> AND .)
    FLOAT           reduce using rule 45 (comparacion -> AND .)
    BOOL            reduce using rule 45 (comparacion -> AND .)
    STRING          reduce using rule 45 (comparacion -> AND .)
    LBRACKET        reduce using rule 45 (comparacion -> AND .)


state 112

    (46) comparacion -> OR .

    ID              reduce using rule 46 (comparacion -> OR .)
    LPAREN          reduce using rule 46 (comparacion -> OR .)
    INT             reduce using rule 46 (comparacion -> OR .)
    FLOAT           reduce using rule 46 (comparacion -> OR .)
    BOOL            reduce using rule 46 (comparacion -> OR .)
    STRING          reduce using rule 46 (comparacion -> OR .)
    LBRACKET        reduce using rule 46 (comparacion -> OR .)


state 113

    (79) exp -> termino signo . exp
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (68) functionCall -> . funCall lparen funcArgs rparen
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (69) funCall -> . ID
    (103) openBracket -> . LBRACKET
    (101) callArr -> . ID

    ID              shift and go to state 147
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    termino                        shift and go to state 66
    exp                            shift and go to state 145
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    lparen                         shift and go to state 67
    functionCall                   shift and go to state 146
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76
    matrix                         shift and go to state 69
    arr                            shift and go to state 148
    funCall                        shift and go to state 32
    openBracket                    shift and go to state 68
    callArr                        shift and go to state 35

state 114

    (80) signo -> PLUS .

    ID              reduce using rule 80 (signo -> PLUS .)
    LPAREN          reduce using rule 80 (signo -> PLUS .)
    INT             reduce using rule 80 (signo -> PLUS .)
    FLOAT           reduce using rule 80 (signo -> PLUS .)
    BOOL            reduce using rule 80 (signo -> PLUS .)
    STRING          reduce using rule 80 (signo -> PLUS .)
    LBRACKET        reduce using rule 80 (signo -> PLUS .)


state 115

    (81) signo -> MINUS .

    ID              reduce using rule 81 (signo -> MINUS .)
    LPAREN          reduce using rule 81 (signo -> MINUS .)
    INT             reduce using rule 81 (signo -> MINUS .)
    FLOAT           reduce using rule 81 (signo -> MINUS .)
    BOOL            reduce using rule 81 (signo -> MINUS .)
    STRING          reduce using rule 81 (signo -> MINUS .)
    LBRACKET        reduce using rule 81 (signo -> MINUS .)


state 116

    (89) factor -> lparen expresion . rparen
    (92) rparen -> . RPAREN

    RPAREN          shift and go to state 143

    rparen                         shift and go to state 149

state 117

    (102) matrix -> openBracket expresion . mbracket
    (106) mbracket -> . closeBracket
    (104) closeBracket -> . RBRACKET

    RBRACKET        shift and go to state 152

    mbracket                       shift and go to state 150
    closeBracket                   shift and go to state 151

state 118

    (83) termino -> factor operacion . termino
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (68) functionCall -> . funCall lparen funcArgs rparen
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (69) funCall -> . ID
    (103) openBracket -> . LBRACKET
    (101) callArr -> . ID

    ID              shift and go to state 147
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    factor                         shift and go to state 70
    termino                        shift and go to state 153
    varcte                         shift and go to state 72
    lparen                         shift and go to state 67
    functionCall                   shift and go to state 146
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76
    matrix                         shift and go to state 69
    arr                            shift and go to state 148
    funCall                        shift and go to state 32
    openBracket                    shift and go to state 68
    callArr                        shift and go to state 35

state 119

    (84) operacion -> TIMES .

    ID              reduce using rule 84 (operacion -> TIMES .)
    LPAREN          reduce using rule 84 (operacion -> TIMES .)
    INT             reduce using rule 84 (operacion -> TIMES .)
    FLOAT           reduce using rule 84 (operacion -> TIMES .)
    BOOL            reduce using rule 84 (operacion -> TIMES .)
    STRING          reduce using rule 84 (operacion -> TIMES .)
    LBRACKET        reduce using rule 84 (operacion -> TIMES .)


state 120

    (85) operacion -> DIVIDE .

    ID              reduce using rule 85 (operacion -> DIVIDE .)
    LPAREN          reduce using rule 85 (operacion -> DIVIDE .)
    INT             reduce using rule 85 (operacion -> DIVIDE .)
    FLOAT           reduce using rule 85 (operacion -> DIVIDE .)
    BOOL            reduce using rule 85 (operacion -> DIVIDE .)
    STRING          reduce using rule 85 (operacion -> DIVIDE .)
    LBRACKET        reduce using rule 85 (operacion -> DIVIDE .)


state 121

    (86) operacion -> DIFF .

    ID              reduce using rule 86 (operacion -> DIFF .)
    LPAREN          reduce using rule 86 (operacion -> DIFF .)
    INT             reduce using rule 86 (operacion -> DIFF .)
    FLOAT           reduce using rule 86 (operacion -> DIFF .)
    BOOL            reduce using rule 86 (operacion -> DIFF .)
    STRING          reduce using rule 86 (operacion -> DIFF .)
    LBRACKET        reduce using rule 86 (operacion -> DIFF .)


state 122

    (87) operacion -> EXP .

    ID              reduce using rule 87 (operacion -> EXP .)
    LPAREN          reduce using rule 87 (operacion -> EXP .)
    INT             reduce using rule 87 (operacion -> EXP .)
    FLOAT           reduce using rule 87 (operacion -> EXP .)
    BOOL            reduce using rule 87 (operacion -> EXP .)
    STRING          reduce using rule 87 (operacion -> EXP .)
    LBRACKET        reduce using rule 87 (operacion -> EXP .)


state 123

    (107) input -> INPUT LPAREN ID . RPAREN

    RPAREN          shift and go to state 154


state 124

    (99) arr -> callArr openBracket expresion . abracket matrix
    (100) arr -> callArr openBracket expresion . abracket epsilon
    (105) abracket -> . closeBracket
    (104) closeBracket -> . RBRACKET

    RBRACKET        shift and go to state 152

    abracket                       shift and go to state 155
    closeBracket                   shift and go to state 156

state 125

    (6) var -> vardef COLON tipo . SEMICOLON

    SEMICOLON       shift and go to state 157


state 126

    (10) tipo -> INT .

    SEMICOLON       reduce using rule 10 (tipo -> INT .)


state 127

    (11) tipo -> FLOAT .

    SEMICOLON       reduce using rule 11 (tipo -> FLOAT .)


state 128

    (12) tipo -> BOOL .

    SEMICOLON       reduce using rule 12 (tipo -> BOOL .)


state 129

    (13) tipo -> STRING .

    SEMICOLON       reduce using rule 13 (tipo -> STRING .)


state 130

    (95) declaracionArr -> arrDef LBRACKET INT . RBRACKET COLON tipo
    (96) declaracionMatrix -> arrDef LBRACKET INT . RBRACKET LBRACKET INT RBRACKET COLON tipo

    RBRACKET        shift and go to state 158


state 131

    (53) condicion -> IF LPAREN expresion endCondition . bloque condicionelse
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 159

state 132

    (54) endCondition -> RPAREN .

    LCURLY          reduce using rule 54 (endCondition -> RPAREN .)
    ID              reduce using rule 54 (endCondition -> RPAREN .)


state 133

    (55) endCondition -> SEMICOLON .

    LCURLY          reduce using rule 55 (endCondition -> SEMICOLON .)
    ID              reduce using rule 55 (endCondition -> SEMICOLON .)


state 134

    (49) whileLoop -> WHILE startCondition expresion endCondition . bloque
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 160

state 135

    (47) doWhile -> do bloque WHILE LPAREN . expresion RPAREN
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    expresion                      shift and go to state 161
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 136

    (52) forLoop -> FOR LPAREN argumentos startCondition . expresion endCondition asignacion RPAREN bloque
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    expresion                      shift and go to state 162
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 137

    (77) args -> args COMA . args
    (76) args -> . asignacion
    (77) args -> . args COMA args
    (31) asignacion -> . ID EQUAL expresion

    ID              shift and go to state 97

    args                           shift and go to state 163
    asignacion                     shift and go to state 94

state 138

    (32) escritura -> PRINT LPAREN escrito RPAREN .

    SEMICOLON       reduce using rule 32 (escritura -> PRINT LPAREN escrito RPAREN .)


state 139

    (34) escrito -> impr COMA . escrito
    (33) escrito -> . impr
    (34) escrito -> . impr COMA escrito
    (35) impr -> . expresion
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    impr                           shift and go to state 99
    escrito                        shift and go to state 164
    expresion                      shift and go to state 100
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 140

    (59) funcion -> FUNCTION funcdef LPAREN declaracion . addArgs RPAREN COLON tiposreturn
    (60) addArgs -> . epsilon
    (93) epsilon -> .

    RPAREN          reduce using rule 93 (epsilon -> .)

    addArgs                        shift and go to state 165
    epsilon                        shift and go to state 166

state 141

    (68) functionCall -> funCall lparen funcArgs rparen .

    SEMICOLON       reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    TIMES           reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    DIVIDE          reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    DIFF            reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    EXP             reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    PLUS            reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    MINUS           reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    LESSTHAN        reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    MORETHAN        reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    ISEQUAL         reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    NOTEQUAL        reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    AND             reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    OR              reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    COMA            reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    LPAREN          reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    RPAREN          reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)
    RBRACKET        reduce using rule 68 (functionCall -> funCall lparen funcArgs rparen .)


state 142

    (71) funcArgs -> funcArgs COMA . funcArgs
    (70) funcArgs -> . checkArgs
    (71) funcArgs -> . funcArgs COMA funcArgs
    (72) funcArgs -> . epsilon
    (73) checkArgs -> . expresion
    (93) epsilon -> .
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    COMA            reduce using rule 93 (epsilon -> .)
    RPAREN          reduce using rule 93 (epsilon -> .)
    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    funcArgs                       shift and go to state 167
    checkArgs                      shift and go to state 103
    epsilon                        shift and go to state 104
    expresion                      shift and go to state 105
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 143

    (92) rparen -> RPAREN .

    SEMICOLON       reduce using rule 92 (rparen -> RPAREN .)
    TIMES           reduce using rule 92 (rparen -> RPAREN .)
    DIVIDE          reduce using rule 92 (rparen -> RPAREN .)
    DIFF            reduce using rule 92 (rparen -> RPAREN .)
    EXP             reduce using rule 92 (rparen -> RPAREN .)
    PLUS            reduce using rule 92 (rparen -> RPAREN .)
    MINUS           reduce using rule 92 (rparen -> RPAREN .)
    LESSTHAN        reduce using rule 92 (rparen -> RPAREN .)
    MORETHAN        reduce using rule 92 (rparen -> RPAREN .)
    ISEQUAL         reduce using rule 92 (rparen -> RPAREN .)
    NOTEQUAL        reduce using rule 92 (rparen -> RPAREN .)
    AND             reduce using rule 92 (rparen -> RPAREN .)
    OR              reduce using rule 92 (rparen -> RPAREN .)
    COMA            reduce using rule 92 (rparen -> RPAREN .)
    LPAREN          reduce using rule 92 (rparen -> RPAREN .)
    RPAREN          reduce using rule 92 (rparen -> RPAREN .)
    RBRACKET        reduce using rule 92 (rparen -> RPAREN .)


state 144

    (40) condition -> exp comparacion expresion .

    SEMICOLON       reduce using rule 40 (condition -> exp comparacion expresion .)
    COMA            reduce using rule 40 (condition -> exp comparacion expresion .)
    LPAREN          reduce using rule 40 (condition -> exp comparacion expresion .)
    RPAREN          reduce using rule 40 (condition -> exp comparacion expresion .)
    RBRACKET        reduce using rule 40 (condition -> exp comparacion expresion .)


state 145

    (79) exp -> termino signo exp .

    LESSTHAN        reduce using rule 79 (exp -> termino signo exp .)
    MORETHAN        reduce using rule 79 (exp -> termino signo exp .)
    ISEQUAL         reduce using rule 79 (exp -> termino signo exp .)
    NOTEQUAL        reduce using rule 79 (exp -> termino signo exp .)
    AND             reduce using rule 79 (exp -> termino signo exp .)
    OR              reduce using rule 79 (exp -> termino signo exp .)
    SEMICOLON       reduce using rule 79 (exp -> termino signo exp .)
    COMA            reduce using rule 79 (exp -> termino signo exp .)
    LPAREN          reduce using rule 79 (exp -> termino signo exp .)
    RPAREN          reduce using rule 79 (exp -> termino signo exp .)
    RBRACKET        reduce using rule 79 (exp -> termino signo exp .)


state 146

    (90) factor -> functionCall .

    TIMES           reduce using rule 90 (factor -> functionCall .)
    DIVIDE          reduce using rule 90 (factor -> functionCall .)
    DIFF            reduce using rule 90 (factor -> functionCall .)
    EXP             reduce using rule 90 (factor -> functionCall .)
    PLUS            reduce using rule 90 (factor -> functionCall .)
    MINUS           reduce using rule 90 (factor -> functionCall .)
    LESSTHAN        reduce using rule 90 (factor -> functionCall .)
    MORETHAN        reduce using rule 90 (factor -> functionCall .)
    ISEQUAL         reduce using rule 90 (factor -> functionCall .)
    NOTEQUAL        reduce using rule 90 (factor -> functionCall .)
    AND             reduce using rule 90 (factor -> functionCall .)
    OR              reduce using rule 90 (factor -> functionCall .)
    SEMICOLON       reduce using rule 90 (factor -> functionCall .)
    COMA            reduce using rule 90 (factor -> functionCall .)
    LPAREN          reduce using rule 90 (factor -> functionCall .)
    RPAREN          reduce using rule 90 (factor -> functionCall .)
    RBRACKET        reduce using rule 90 (factor -> functionCall .)


state 147

    (108) varcte -> ID .
    (69) funCall -> ID .
    (101) callArr -> ID .

  ! reduce/reduce conflict for LPAREN resolved using rule 69 (funCall -> ID .)
    TIMES           reduce using rule 108 (varcte -> ID .)
    DIVIDE          reduce using rule 108 (varcte -> ID .)
    DIFF            reduce using rule 108 (varcte -> ID .)
    EXP             reduce using rule 108 (varcte -> ID .)
    PLUS            reduce using rule 108 (varcte -> ID .)
    MINUS           reduce using rule 108 (varcte -> ID .)
    LESSTHAN        reduce using rule 108 (varcte -> ID .)
    MORETHAN        reduce using rule 108 (varcte -> ID .)
    ISEQUAL         reduce using rule 108 (varcte -> ID .)
    NOTEQUAL        reduce using rule 108 (varcte -> ID .)
    AND             reduce using rule 108 (varcte -> ID .)
    OR              reduce using rule 108 (varcte -> ID .)
    SEMICOLON       reduce using rule 108 (varcte -> ID .)
    COMA            reduce using rule 108 (varcte -> ID .)
    RPAREN          reduce using rule 108 (varcte -> ID .)
    RBRACKET        reduce using rule 108 (varcte -> ID .)
    LPAREN          reduce using rule 69 (funCall -> ID .)
    LBRACKET        reduce using rule 101 (callArr -> ID .)

  ! LPAREN          [ reduce using rule 108 (varcte -> ID .) ]


state 148

    (114) varcte -> arr .

    TIMES           reduce using rule 114 (varcte -> arr .)
    DIVIDE          reduce using rule 114 (varcte -> arr .)
    DIFF            reduce using rule 114 (varcte -> arr .)
    EXP             reduce using rule 114 (varcte -> arr .)
    PLUS            reduce using rule 114 (varcte -> arr .)
    MINUS           reduce using rule 114 (varcte -> arr .)
    LESSTHAN        reduce using rule 114 (varcte -> arr .)
    MORETHAN        reduce using rule 114 (varcte -> arr .)
    ISEQUAL         reduce using rule 114 (varcte -> arr .)
    NOTEQUAL        reduce using rule 114 (varcte -> arr .)
    AND             reduce using rule 114 (varcte -> arr .)
    OR              reduce using rule 114 (varcte -> arr .)
    SEMICOLON       reduce using rule 114 (varcte -> arr .)
    COMA            reduce using rule 114 (varcte -> arr .)
    LPAREN          reduce using rule 114 (varcte -> arr .)
    RPAREN          reduce using rule 114 (varcte -> arr .)
    RBRACKET        reduce using rule 114 (varcte -> arr .)


state 149

    (89) factor -> lparen expresion rparen .

    TIMES           reduce using rule 89 (factor -> lparen expresion rparen .)
    DIVIDE          reduce using rule 89 (factor -> lparen expresion rparen .)
    DIFF            reduce using rule 89 (factor -> lparen expresion rparen .)
    EXP             reduce using rule 89 (factor -> lparen expresion rparen .)
    PLUS            reduce using rule 89 (factor -> lparen expresion rparen .)
    MINUS           reduce using rule 89 (factor -> lparen expresion rparen .)
    LESSTHAN        reduce using rule 89 (factor -> lparen expresion rparen .)
    MORETHAN        reduce using rule 89 (factor -> lparen expresion rparen .)
    ISEQUAL         reduce using rule 89 (factor -> lparen expresion rparen .)
    NOTEQUAL        reduce using rule 89 (factor -> lparen expresion rparen .)
    AND             reduce using rule 89 (factor -> lparen expresion rparen .)
    OR              reduce using rule 89 (factor -> lparen expresion rparen .)
    SEMICOLON       reduce using rule 89 (factor -> lparen expresion rparen .)
    COMA            reduce using rule 89 (factor -> lparen expresion rparen .)
    LPAREN          reduce using rule 89 (factor -> lparen expresion rparen .)
    RPAREN          reduce using rule 89 (factor -> lparen expresion rparen .)
    RBRACKET        reduce using rule 89 (factor -> lparen expresion rparen .)


state 150

    (102) matrix -> openBracket expresion mbracket .

    TIMES           reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    DIVIDE          reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    DIFF            reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    EXP             reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    PLUS            reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    MINUS           reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    LESSTHAN        reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    MORETHAN        reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    ISEQUAL         reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    NOTEQUAL        reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    AND             reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    OR              reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    SEMICOLON       reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    COMA            reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    LPAREN          reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    RPAREN          reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    RBRACKET        reduce using rule 102 (matrix -> openBracket expresion mbracket .)
    EQUAL           reduce using rule 102 (matrix -> openBracket expresion mbracket .)


state 151

    (106) mbracket -> closeBracket .

    TIMES           reduce using rule 106 (mbracket -> closeBracket .)
    DIVIDE          reduce using rule 106 (mbracket -> closeBracket .)
    DIFF            reduce using rule 106 (mbracket -> closeBracket .)
    EXP             reduce using rule 106 (mbracket -> closeBracket .)
    PLUS            reduce using rule 106 (mbracket -> closeBracket .)
    MINUS           reduce using rule 106 (mbracket -> closeBracket .)
    LESSTHAN        reduce using rule 106 (mbracket -> closeBracket .)
    MORETHAN        reduce using rule 106 (mbracket -> closeBracket .)
    ISEQUAL         reduce using rule 106 (mbracket -> closeBracket .)
    NOTEQUAL        reduce using rule 106 (mbracket -> closeBracket .)
    AND             reduce using rule 106 (mbracket -> closeBracket .)
    OR              reduce using rule 106 (mbracket -> closeBracket .)
    SEMICOLON       reduce using rule 106 (mbracket -> closeBracket .)
    COMA            reduce using rule 106 (mbracket -> closeBracket .)
    LPAREN          reduce using rule 106 (mbracket -> closeBracket .)
    RPAREN          reduce using rule 106 (mbracket -> closeBracket .)
    RBRACKET        reduce using rule 106 (mbracket -> closeBracket .)
    EQUAL           reduce using rule 106 (mbracket -> closeBracket .)


state 152

    (104) closeBracket -> RBRACKET .

    TIMES           reduce using rule 104 (closeBracket -> RBRACKET .)
    DIVIDE          reduce using rule 104 (closeBracket -> RBRACKET .)
    DIFF            reduce using rule 104 (closeBracket -> RBRACKET .)
    EXP             reduce using rule 104 (closeBracket -> RBRACKET .)
    PLUS            reduce using rule 104 (closeBracket -> RBRACKET .)
    MINUS           reduce using rule 104 (closeBracket -> RBRACKET .)
    LESSTHAN        reduce using rule 104 (closeBracket -> RBRACKET .)
    MORETHAN        reduce using rule 104 (closeBracket -> RBRACKET .)
    ISEQUAL         reduce using rule 104 (closeBracket -> RBRACKET .)
    NOTEQUAL        reduce using rule 104 (closeBracket -> RBRACKET .)
    AND             reduce using rule 104 (closeBracket -> RBRACKET .)
    OR              reduce using rule 104 (closeBracket -> RBRACKET .)
    SEMICOLON       reduce using rule 104 (closeBracket -> RBRACKET .)
    COMA            reduce using rule 104 (closeBracket -> RBRACKET .)
    LPAREN          reduce using rule 104 (closeBracket -> RBRACKET .)
    RPAREN          reduce using rule 104 (closeBracket -> RBRACKET .)
    RBRACKET        reduce using rule 104 (closeBracket -> RBRACKET .)
    EQUAL           reduce using rule 104 (closeBracket -> RBRACKET .)
    LBRACKET        reduce using rule 104 (closeBracket -> RBRACKET .)


state 153

    (83) termino -> factor operacion termino .

    PLUS            reduce using rule 83 (termino -> factor operacion termino .)
    MINUS           reduce using rule 83 (termino -> factor operacion termino .)
    LESSTHAN        reduce using rule 83 (termino -> factor operacion termino .)
    MORETHAN        reduce using rule 83 (termino -> factor operacion termino .)
    ISEQUAL         reduce using rule 83 (termino -> factor operacion termino .)
    NOTEQUAL        reduce using rule 83 (termino -> factor operacion termino .)
    AND             reduce using rule 83 (termino -> factor operacion termino .)
    OR              reduce using rule 83 (termino -> factor operacion termino .)
    SEMICOLON       reduce using rule 83 (termino -> factor operacion termino .)
    COMA            reduce using rule 83 (termino -> factor operacion termino .)
    LPAREN          reduce using rule 83 (termino -> factor operacion termino .)
    RPAREN          reduce using rule 83 (termino -> factor operacion termino .)
    RBRACKET        reduce using rule 83 (termino -> factor operacion termino .)


state 154

    (107) input -> INPUT LPAREN ID RPAREN .

    SEMICOLON       reduce using rule 107 (input -> INPUT LPAREN ID RPAREN .)


state 155

    (99) arr -> callArr openBracket expresion abracket . matrix
    (100) arr -> callArr openBracket expresion abracket . epsilon
    (102) matrix -> . openBracket expresion mbracket
    (93) epsilon -> .
    (103) openBracket -> . LBRACKET

    EQUAL           reduce using rule 93 (epsilon -> .)
    SEMICOLON       reduce using rule 93 (epsilon -> .)
    TIMES           reduce using rule 93 (epsilon -> .)
    DIVIDE          reduce using rule 93 (epsilon -> .)
    DIFF            reduce using rule 93 (epsilon -> .)
    EXP             reduce using rule 93 (epsilon -> .)
    PLUS            reduce using rule 93 (epsilon -> .)
    MINUS           reduce using rule 93 (epsilon -> .)
    LESSTHAN        reduce using rule 93 (epsilon -> .)
    MORETHAN        reduce using rule 93 (epsilon -> .)
    ISEQUAL         reduce using rule 93 (epsilon -> .)
    NOTEQUAL        reduce using rule 93 (epsilon -> .)
    AND             reduce using rule 93 (epsilon -> .)
    OR              reduce using rule 93 (epsilon -> .)
    COMA            reduce using rule 93 (epsilon -> .)
    LPAREN          reduce using rule 93 (epsilon -> .)
    RPAREN          reduce using rule 93 (epsilon -> .)
    RBRACKET        reduce using rule 93 (epsilon -> .)
    LBRACKET        shift and go to state 81

    openBracket                    shift and go to state 68
    matrix                         shift and go to state 168
    epsilon                        shift and go to state 169

state 156

    (105) abracket -> closeBracket .

    LBRACKET        reduce using rule 105 (abracket -> closeBracket .)
    EQUAL           reduce using rule 105 (abracket -> closeBracket .)
    SEMICOLON       reduce using rule 105 (abracket -> closeBracket .)
    TIMES           reduce using rule 105 (abracket -> closeBracket .)
    DIVIDE          reduce using rule 105 (abracket -> closeBracket .)
    DIFF            reduce using rule 105 (abracket -> closeBracket .)
    EXP             reduce using rule 105 (abracket -> closeBracket .)
    PLUS            reduce using rule 105 (abracket -> closeBracket .)
    MINUS           reduce using rule 105 (abracket -> closeBracket .)
    LESSTHAN        reduce using rule 105 (abracket -> closeBracket .)
    MORETHAN        reduce using rule 105 (abracket -> closeBracket .)
    ISEQUAL         reduce using rule 105 (abracket -> closeBracket .)
    NOTEQUAL        reduce using rule 105 (abracket -> closeBracket .)
    AND             reduce using rule 105 (abracket -> closeBracket .)
    OR              reduce using rule 105 (abracket -> closeBracket .)
    COMA            reduce using rule 105 (abracket -> closeBracket .)
    LPAREN          reduce using rule 105 (abracket -> closeBracket .)
    RPAREN          reduce using rule 105 (abracket -> closeBracket .)
    RBRACKET        reduce using rule 105 (abracket -> closeBracket .)


state 157

    (6) var -> vardef COLON tipo SEMICOLON .

    VAR             reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    ID              reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    IF              reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    WHILE           reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    FOR             reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    PRINT           reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    FUNCTION        reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    BREAK           reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    INPUT           reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    DO              reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)
    RPAREN          reduce using rule 6 (var -> vardef COLON tipo SEMICOLON .)


state 158

    (95) declaracionArr -> arrDef LBRACKET INT RBRACKET . COLON tipo
    (96) declaracionMatrix -> arrDef LBRACKET INT RBRACKET . LBRACKET INT RBRACKET COLON tipo

    COLON           shift and go to state 171
    LBRACKET        shift and go to state 170


state 159

    (53) condicion -> IF LPAREN expresion endCondition bloque . condicionelse
    (56) condicionelse -> . else bloque
    (57) condicionelse -> . epsilon
    (58) else -> . ELSE
    (93) epsilon -> .

    ELSE            shift and go to state 175
    SEMICOLON       reduce using rule 93 (epsilon -> .)

    condicionelse                  shift and go to state 172
    else                           shift and go to state 173
    epsilon                        shift and go to state 174

state 160

    (49) whileLoop -> WHILE startCondition expresion endCondition bloque .

    SEMICOLON       reduce using rule 49 (whileLoop -> WHILE startCondition expresion endCondition bloque .)


state 161

    (47) doWhile -> do bloque WHILE LPAREN expresion . RPAREN

    RPAREN          shift and go to state 176


state 162

    (52) forLoop -> FOR LPAREN argumentos startCondition expresion . endCondition asignacion RPAREN bloque
    (54) endCondition -> . RPAREN
    (55) endCondition -> . SEMICOLON

    RPAREN          shift and go to state 132
    SEMICOLON       shift and go to state 133

    endCondition                   shift and go to state 177

state 163

    (77) args -> args COMA args .
    (77) args -> args . COMA args

  ! shift/reduce conflict for COMA resolved as shift
    LPAREN          reduce using rule 77 (args -> args COMA args .)
    SEMICOLON       reduce using rule 77 (args -> args COMA args .)
    COMA            shift and go to state 137

  ! COMA            [ reduce using rule 77 (args -> args COMA args .) ]


state 164

    (34) escrito -> impr COMA escrito .

    RPAREN          reduce using rule 34 (escrito -> impr COMA escrito .)


state 165

    (59) funcion -> FUNCTION funcdef LPAREN declaracion addArgs . RPAREN COLON tiposreturn

    RPAREN          shift and go to state 178


state 166

    (60) addArgs -> epsilon .

    RPAREN          reduce using rule 60 (addArgs -> epsilon .)


state 167

    (71) funcArgs -> funcArgs COMA funcArgs .
    (71) funcArgs -> funcArgs . COMA funcArgs

  ! shift/reduce conflict for COMA resolved as shift
    RPAREN          reduce using rule 71 (funcArgs -> funcArgs COMA funcArgs .)
    COMA            shift and go to state 142

  ! COMA            [ reduce using rule 71 (funcArgs -> funcArgs COMA funcArgs .) ]


state 168

    (99) arr -> callArr openBracket expresion abracket matrix .

    EQUAL           reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    SEMICOLON       reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    TIMES           reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    DIVIDE          reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    DIFF            reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    EXP             reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    PLUS            reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    MINUS           reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    LESSTHAN        reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    MORETHAN        reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    ISEQUAL         reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    NOTEQUAL        reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    AND             reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    OR              reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    COMA            reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    LPAREN          reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    RPAREN          reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)
    RBRACKET        reduce using rule 99 (arr -> callArr openBracket expresion abracket matrix .)


state 169

    (100) arr -> callArr openBracket expresion abracket epsilon .

    EQUAL           reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    SEMICOLON       reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    TIMES           reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    DIVIDE          reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    DIFF            reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    EXP             reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    PLUS            reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    MINUS           reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    LESSTHAN        reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    MORETHAN        reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    ISEQUAL         reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    NOTEQUAL        reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    AND             reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    OR              reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    COMA            reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    LPAREN          reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    RPAREN          reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)
    RBRACKET        reduce using rule 100 (arr -> callArr openBracket expresion abracket epsilon .)


state 170

    (96) declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET . INT RBRACKET COLON tipo

    INT             shift and go to state 179


state 171

    (95) declaracionArr -> arrDef LBRACKET INT RBRACKET COLON . tipo
    (10) tipo -> . INT
    (11) tipo -> . FLOAT
    (12) tipo -> . BOOL
    (13) tipo -> . STRING

    INT             shift and go to state 126
    FLOAT           shift and go to state 127
    BOOL            shift and go to state 128
    STRING          shift and go to state 129

    tipo                           shift and go to state 180

state 172

    (53) condicion -> IF LPAREN expresion endCondition bloque condicionelse .

    SEMICOLON       reduce using rule 53 (condicion -> IF LPAREN expresion endCondition bloque condicionelse .)


state 173

    (56) condicionelse -> else . bloque
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 181

state 174

    (57) condicionelse -> epsilon .

    SEMICOLON       reduce using rule 57 (condicionelse -> epsilon .)


state 175

    (58) else -> ELSE .

    LCURLY          reduce using rule 58 (else -> ELSE .)


state 176

    (47) doWhile -> do bloque WHILE LPAREN expresion RPAREN .

    SEMICOLON       reduce using rule 47 (doWhile -> do bloque WHILE LPAREN expresion RPAREN .)


state 177

    (52) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition . asignacion RPAREN bloque
    (31) asignacion -> . ID EQUAL expresion

    ID              shift and go to state 97

    asignacion                     shift and go to state 182

state 178

    (59) funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN . COLON tiposreturn

    COLON           shift and go to state 183


state 179

    (96) declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT . RBRACKET COLON tipo

    RBRACKET        shift and go to state 184


state 180

    (95) declaracionArr -> arrDef LBRACKET INT RBRACKET COLON tipo .

    SEMICOLON       reduce using rule 95 (declaracionArr -> arrDef LBRACKET INT RBRACKET COLON tipo .)


state 181

    (56) condicionelse -> else bloque .

    SEMICOLON       reduce using rule 56 (condicionelse -> else bloque .)


state 182

    (52) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion . RPAREN bloque

    RPAREN          shift and go to state 185


state 183

    (59) funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON . tiposreturn
    (62) tiposreturn -> . tiposFuncion bloqueReturn
    (63) tiposreturn -> . VOID bloque
    (64) tiposFuncion -> . INT
    (65) tiposFuncion -> . FLOAT
    (66) tiposFuncion -> . BOOL
    (67) tiposFuncion -> . STRING

    VOID            shift and go to state 188
    INT             shift and go to state 189
    FLOAT           shift and go to state 190
    BOOL            shift and go to state 191
    STRING          shift and go to state 192

    tiposreturn                    shift and go to state 186
    tiposFuncion                   shift and go to state 187

state 184

    (96) declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET . COLON tipo

    COLON           shift and go to state 193


state 185

    (52) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN . bloque
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 194

state 186

    (59) funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn .

    SEMICOLON       reduce using rule 59 (funcion -> FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn .)


state 187

    (62) tiposreturn -> tiposFuncion . bloqueReturn
    (15) bloqueReturn -> . LCURLY declaracion estatutoExp returnexp RCURLY

    LCURLY          shift and go to state 196

    bloqueReturn                   shift and go to state 195

state 188

    (63) tiposreturn -> VOID . bloque
    (14) bloque -> . LCURLY declaracion estatutoExp RCURLY

    LCURLY          shift and go to state 6

    bloque                         shift and go to state 197

state 189

    (64) tiposFuncion -> INT .

    LCURLY          reduce using rule 64 (tiposFuncion -> INT .)


state 190

    (65) tiposFuncion -> FLOAT .

    LCURLY          reduce using rule 65 (tiposFuncion -> FLOAT .)


state 191

    (66) tiposFuncion -> BOOL .

    LCURLY          reduce using rule 66 (tiposFuncion -> BOOL .)


state 192

    (67) tiposFuncion -> STRING .

    LCURLY          reduce using rule 67 (tiposFuncion -> STRING .)


state 193

    (96) declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON . tipo
    (10) tipo -> . INT
    (11) tipo -> . FLOAT
    (12) tipo -> . BOOL
    (13) tipo -> . STRING

    INT             shift and go to state 126
    FLOAT           shift and go to state 127
    BOOL            shift and go to state 128
    STRING          shift and go to state 129

    tipo                           shift and go to state 198

state 194

    (52) forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque .

    SEMICOLON       reduce using rule 52 (forLoop -> FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque .)


state 195

    (62) tiposreturn -> tiposFuncion bloqueReturn .

    SEMICOLON       reduce using rule 62 (tiposreturn -> tiposFuncion bloqueReturn .)


state 196

    (15) bloqueReturn -> LCURLY . declaracion estatutoExp returnexp RCURLY
    (2) declaracion -> . vars
    (3) declaracion -> . epsilon
    (4) vars -> . VAR var
    (5) vars -> . vars vars
    (93) epsilon -> .

    VAR             shift and go to state 10
    ID              reduce using rule 93 (epsilon -> .)
    IF              reduce using rule 93 (epsilon -> .)
    WHILE           reduce using rule 93 (epsilon -> .)
    FOR             reduce using rule 93 (epsilon -> .)
    PRINT           reduce using rule 93 (epsilon -> .)
    FUNCTION        reduce using rule 93 (epsilon -> .)
    BREAK           reduce using rule 93 (epsilon -> .)
    INPUT           reduce using rule 93 (epsilon -> .)
    DO              reduce using rule 93 (epsilon -> .)

    declaracion                    shift and go to state 199
    vars                           shift and go to state 8
    epsilon                        shift and go to state 9

state 197

    (63) tiposreturn -> VOID bloque .

    SEMICOLON       reduce using rule 63 (tiposreturn -> VOID bloque .)


state 198

    (96) declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON tipo .

    SEMICOLON       reduce using rule 96 (declaracionMatrix -> arrDef LBRACKET INT RBRACKET LBRACKET INT RBRACKET COLON tipo .)


state 199

    (15) bloqueReturn -> LCURLY declaracion . estatutoExp returnexp RCURLY
    (16) estatutoExp -> . estatuto SEMICOLON
    (17) estatutoExp -> . estatutoExp estatutoExp
    (18) estatuto -> . asignacion
    (19) estatuto -> . asignacionArr
    (20) estatuto -> . condicion
    (21) estatuto -> . whileLoop
    (22) estatuto -> . doWhile
    (23) estatuto -> . forLoop
    (24) estatuto -> . escritura
    (25) estatuto -> . funcion
    (26) estatuto -> . functionCall
    (27) estatuto -> . break
    (28) estatuto -> . input
    (31) asignacion -> . ID EQUAL expresion
    (97) asignacionArr -> . arr arrayEqual expresion
    (53) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (49) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (47) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (52) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (32) escritura -> . PRINT LPAREN escrito RPAREN
    (59) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (68) functionCall -> . funCall lparen funcArgs rparen
    (29) break -> . BREAK expresion
    (107) input -> . INPUT LPAREN ID RPAREN
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (48) do -> . DO
    (69) funCall -> . ID
    (101) callArr -> . ID

    ID              shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    FUNCTION        shift and go to state 31
    BREAK           shift and go to state 33
    INPUT           shift and go to state 34
    DO              shift and go to state 36

    estatutoExp                    shift and go to state 200
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    asignacionArr                  shift and go to state 14
    condicion                      shift and go to state 15
    whileLoop                      shift and go to state 16
    doWhile                        shift and go to state 17
    forLoop                        shift and go to state 18
    escritura                      shift and go to state 19
    funcion                        shift and go to state 20
    functionCall                   shift and go to state 21
    break                          shift and go to state 22
    input                          shift and go to state 23
    arr                            shift and go to state 25
    do                             shift and go to state 28
    funCall                        shift and go to state 32
    callArr                        shift and go to state 35

state 200

    (15) bloqueReturn -> LCURLY declaracion estatutoExp . returnexp RCURLY
    (17) estatutoExp -> estatutoExp . estatutoExp
    (30) returnexp -> . RETURN expresion SEMICOLON
    (16) estatutoExp -> . estatuto SEMICOLON
    (17) estatutoExp -> . estatutoExp estatutoExp
    (18) estatuto -> . asignacion
    (19) estatuto -> . asignacionArr
    (20) estatuto -> . condicion
    (21) estatuto -> . whileLoop
    (22) estatuto -> . doWhile
    (23) estatuto -> . forLoop
    (24) estatuto -> . escritura
    (25) estatuto -> . funcion
    (26) estatuto -> . functionCall
    (27) estatuto -> . break
    (28) estatuto -> . input
    (31) asignacion -> . ID EQUAL expresion
    (97) asignacionArr -> . arr arrayEqual expresion
    (53) condicion -> . IF LPAREN expresion endCondition bloque condicionelse
    (49) whileLoop -> . WHILE startCondition expresion endCondition bloque
    (47) doWhile -> . do bloque WHILE LPAREN expresion RPAREN
    (52) forLoop -> . FOR LPAREN argumentos startCondition expresion endCondition asignacion RPAREN bloque
    (32) escritura -> . PRINT LPAREN escrito RPAREN
    (59) funcion -> . FUNCTION funcdef LPAREN declaracion addArgs RPAREN COLON tiposreturn
    (68) functionCall -> . funCall lparen funcArgs rparen
    (29) break -> . BREAK expresion
    (107) input -> . INPUT LPAREN ID RPAREN
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (48) do -> . DO
    (69) funCall -> . ID
    (101) callArr -> . ID

    RETURN          shift and go to state 202
    ID              shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 29
    PRINT           shift and go to state 30
    FUNCTION        shift and go to state 31
    BREAK           shift and go to state 33
    INPUT           shift and go to state 34
    DO              shift and go to state 36

    estatutoExp                    shift and go to state 44
    returnexp                      shift and go to state 201
    estatuto                       shift and go to state 12
    asignacion                     shift and go to state 13
    asignacionArr                  shift and go to state 14
    condicion                      shift and go to state 15
    whileLoop                      shift and go to state 16
    doWhile                        shift and go to state 17
    forLoop                        shift and go to state 18
    escritura                      shift and go to state 19
    funcion                        shift and go to state 20
    functionCall                   shift and go to state 21
    break                          shift and go to state 22
    input                          shift and go to state 23
    arr                            shift and go to state 25
    do                             shift and go to state 28
    funCall                        shift and go to state 32
    callArr                        shift and go to state 35

state 201

    (15) bloqueReturn -> LCURLY declaracion estatutoExp returnexp . RCURLY

    RCURLY          shift and go to state 203


state 202

    (30) returnexp -> RETURN . expresion SEMICOLON
    (36) expresion -> . exp
    (37) expresion -> . condition
    (38) expresion -> . functionCall
    (39) expresion -> . arr
    (78) exp -> . termino
    (79) exp -> . termino signo exp
    (40) condition -> . exp comparacion expresion
    (68) functionCall -> . funCall lparen funcArgs rparen
    (99) arr -> . callArr openBracket expresion abracket matrix
    (100) arr -> . callArr openBracket expresion abracket epsilon
    (82) termino -> . factor
    (83) termino -> . factor operacion termino
    (69) funCall -> . ID
    (101) callArr -> . ID
    (88) factor -> . varcte
    (89) factor -> . lparen expresion rparen
    (90) factor -> . functionCall
    (108) varcte -> . ID
    (109) varcte -> . int
    (110) varcte -> . float
    (111) varcte -> . bool
    (112) varcte -> . string
    (113) varcte -> . matrix
    (114) varcte -> . arr
    (91) lparen -> . LPAREN
    (115) int -> . INT
    (116) float -> . FLOAT
    (117) bool -> . BOOL
    (118) string -> . STRING
    (102) matrix -> . openBracket expresion mbracket
    (103) openBracket -> . LBRACKET

    ID              shift and go to state 71
    LPAREN          shift and go to state 60
    INT             shift and go to state 77
    FLOAT           shift and go to state 78
    BOOL            shift and go to state 79
    STRING          shift and go to state 80
    LBRACKET        shift and go to state 81

    expresion                      shift and go to state 204
    exp                            shift and go to state 62
    condition                      shift and go to state 63
    functionCall                   shift and go to state 64
    arr                            shift and go to state 65
    termino                        shift and go to state 66
    funCall                        shift and go to state 32
    lparen                         shift and go to state 67
    callArr                        shift and go to state 35
    openBracket                    shift and go to state 68
    matrix                         shift and go to state 69
    factor                         shift and go to state 70
    varcte                         shift and go to state 72
    int                            shift and go to state 73
    float                          shift and go to state 74
    bool                           shift and go to state 75
    string                         shift and go to state 76

state 203

    (15) bloqueReturn -> LCURLY declaracion estatutoExp returnexp RCURLY .

    SEMICOLON       reduce using rule 15 (bloqueReturn -> LCURLY declaracion estatutoExp returnexp RCURLY .)


state 204

    (30) returnexp -> RETURN expresion . SEMICOLON

    SEMICOLON       shift and go to state 205


state 205

    (30) returnexp -> RETURN expresion SEMICOLON .

    RCURLY          reduce using rule 30 (returnexp -> RETURN expresion SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VAR in state 37 resolved as shift
WARNING: shift/reduce conflict for ID in state 44 resolved as shift
WARNING: shift/reduce conflict for IF in state 44 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 44 resolved as shift
WARNING: shift/reduce conflict for FOR in state 44 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 44 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 44 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 44 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 44 resolved as shift
WARNING: shift/reduce conflict for DO in state 44 resolved as shift
WARNING: shift/reduce conflict for COMA in state 163 resolved as shift
WARNING: shift/reduce conflict for COMA in state 167 resolved as shift
WARNING: reduce/reduce conflict in state 64 resolved using rule (expresion -> functionCall)
WARNING: rejected rule (factor -> functionCall) in state 64
WARNING: reduce/reduce conflict in state 65 resolved using rule (expresion -> arr)
WARNING: rejected rule (varcte -> arr) in state 65
WARNING: reduce/reduce conflict in state 71 resolved using rule (funCall -> ID)
WARNING: rejected rule (varcte -> ID) in state 71
WARNING: reduce/reduce conflict in state 147 resolved using rule (funCall -> ID)
WARNING: rejected rule (varcte -> ID) in state 147
